<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<style type="text/css"> /* <![CDATA[ */
  @import "tigris-branding/css/tigris.css";
  @import "tigris-branding/css/inst.css";
  /* ]]> */</style>
<link rel="stylesheet" type="text/css" media="print"
  href="tigris-branding/css/print.css"/>
<script type="text/javascript" src="tigris-branding/scripts/tigris.js"></script>
<title>Merge Tracking Requirements and Use Cases</title>
</head>

<body>
<div class="h2">
<h2>Merge Tracking Requirements and Use Cases</h2>

<p style="color: red">*** UNDER CONSTRUCTION ***</p>

<p>This document details Subversion's <a href="index.html">merge
tracking</a> requirements and their supporting use cases, the majority
of which are driven by Subversion's <a
href="../user-classifications.html#developer">Developer</a> and <a
href="../user-classifications.html#merge-meister">Merge Meister</a>
users.  A few outliers are driven by <a
href="../user-classifications.html#program">SCM automation</a>.</p>

<div id="requirements">

<p style="color: red">TODO: Incorporate CollabNet Summit findings.
Remove redundancies.</p>


<div id="cherry-picking">
<h4>Cherry Picking</h4>

<p>Merge of one or more individual changes from branch A into branch
B.  This sometimes involves manual application of the changes from rN
in branch A (e.g. not using <code>svn merge</code>), or manual
adjustment of a change merged into a WC before it's committed to the
repository.  Regardless of the merge method used, Subversion must
provide a way to indicate that the change(s) have been merged into
branch B.</p>

<p>Additionally, it's important to be able to cherry pick changes in
multiple different directions.  For example, if you create a release
branch B by copying the trunk you should be able to both forward port
changes made on B into trunk and backport changes made on trunk into B
without confusing the merge tracking algorithm.</p>

</div>  <!-- cherry picking -->


<div id="auditing">
<h4>Auditing</h4>

<p>Merge tracking must be audit-friendly, supporing some basic forms
of reporting which allow for discovery of following types of
information:</p>

<ul>
  <li>If you merge rN into some destination (e.g. branch B), it should
  be possible to query rN itself to ask what destinations it has been
  merged to, and the answer set should contain B.</li>

  <li>If you merge rN into a branch B, and rN was committed by author A,
  then <code>svn blame</code> should show the changed lines in B as
  last touched by A, even if the merge was committed by you and you
  are not A.  This must also work when merging a range of revisions
  with different authors.</li>

  <li>If you merge rN into a branch B, and rN was committed by author
  A, then <code>svn log -rN</code>should show both the original author
  A, <em>and</em> the author who merged the change.</li>

  <li>It should be possible to query any path (file, directory, or
  symlink) to find out what changes (revisions) have been merged under
  it.  For files, "under" just means "into".</li>

  <li>It should be easy to discover all the paths at which a particular
  node revision (i.e., unique versioned file entity) exists,
  especially in a given revision.  In other words, this is the "what
  branches does this exact version of this file exist in" problem,
  often requested by so-called enterprise-level users.</li>

  <li>Merge records should be transitive.  Often we merge a bunch of
  changes to a backport branch, tweak them there, then later merge the
  branch into a release line.  Later queries of the release line
  should show that the original revisions are present, and queries
  of the original revisions should show that they went to the release
  line as well as the backport branch.</li>
</ul>

</div>  <!-- auditing -->


<div id="repeated-merge">
<h4>Repeated Merge</h4>

<p>Track which changesets have been applied where, so users can
repeatedly merge branch A to branch B without having to remember the
last range of revisions ported.  This would also track changeset <a
href="#cherry-picking">cherry picking</a> done by users, so we don't
accidentally re-merge changesets that are already applied.  This is
the problem that <a href="http://svk.elixus.org/">svk</a> and <a
href="http://www.gnu.org/software/gnu-arch/">arch</a> claim to have
already solved, what they're calling <em>star-merge</em>.</p>

</div>  <!-- repeated-merge -->


<div id="rename-tracking">
<h4>Track Renames in Merge</h4>

<p><code>svn merge</code> needs to handle renames better.  This
requires <a
href="http://subversion.tigris.org/issues/show_bug.cgi?id=898">true
rename support</a>.</p>

<p>Edit foo.c on branch A.  Rename foo.c to bar.c on branch B.</p>

<ol>
  <li>Try merging the branch A edit into a working copy of branchB:
  <code>svn merge</code> will skip the file, because it can't find
  it.</li>

  <li>Conversely, try merging branch B rename to branch A: <code>svn
  merge</code> will delete the 'newer' version of foo.c and add bar.c,
  which has the older text.</li>
</ol>

<p>Problem #2 stems from the fact that we don't have <a
href="http://subversion.tigris.org/issues/show_bug.cgi?id=898">true
renames</a>, just copies (with history) and deletes.  That's not
fixable without a FS schema change, and (probably) a libsvn_wc
rewrite.</p>

<p>It's not clear what it would take to solve problem #1.  See <a
href="http://www.contactor.se/~dast/svn/archive-2004-07/0084.shtml">the
discussion</a> about our rename woes, and the relationship to merge
tracking.</p>

</div>  <!-- rename-tracking -->

<div id="dump-load">
<h4>Allow for Dump/Load</h4>

<p>Whatever solution is chosen must play well with <code>svnadmin
dump</code> and <code>svnadmin load</code>.  For example, the metadata
used to store merge tracking history must not be stored in terms of
some filesystem backend implementation detail (e.g.
"node-revision-ids") unless, perhaps, those IDs are present for all
items in the dump as a sort of "soft data" (which would allow them to
be used for "translating" the merge tracking data at load time, where
those IDs would be otherwise irrelevant).  See <a
href="http://subversion.tigris.org/issues/show_bug.cgi?id=1525">issue
1525</a> about user-visible entity IDs.</p>

</div>  <!-- dump-load -->

<div id="common-case-ease">
<h4>Interface Ease in Common Cases</h4>

(This was one of the points made at
the <a
href="http://svn.collab.net/repos/svn/trunk/notes/EuroOSCON-2005-vc-bof.txt"
>EuroOSCON 2005 Version Control BOF session</a>.)

<p>The interface for common-case merges should be easy.  Currently it
is not.  For example, a very common case is merging all previously
unmerged changes from trunk to branch (more formally, from a source
line to a descendant destination line).  Today, one must type
<code>svn&nbsp;merge&nbsp;-rX:Y&nbsp;URL&nbsp;WC</code>.  But why
can't the dest just remember what has been merged from that src before
and do the right thing?  Then one could type
<code>svn&nbsp;merge&nbsp;SRC&nbsp;DST</code>.  Or better yet,
branches could remember where they come from, and one could just type
<code>svn&nbsp;merge&nbsp;SRC</code>, or
<code>svn&nbsp;merge&nbsp;DST</code>, depending on whether one wants a
push or pull interface.  (It was pointed out that SVK does remember
these things; if someone familiar with the SVK interface wants to put
an example transcript here, that would be great.)</p>

<p>Another common case is porting a single change from one line to
another.  This currently requires <code>-r&lt;X-1&gt;:X</code> syntax,
but Subversion 1.4 will include the <code>-c</code> option (introduced
in r17054), so users will no longer need to perform this menial
arithmetic.  However, Subversion 1.4 will still require the URL of the
merge source to be specified; a merge tracking solution that eases
common cases would obviate the need for the user to supply the URL
when a single change is ported from a branch's ancestor line.</p>

</div>  <!-- common-case-ease -->

<div id="automated-merge">
<h4>SCM Automated Merge</h4>

<p>The ability to automate merges (e.g. from a stable branch to a
development branch), including interfaces for resolving conflicts and
handling other errors, is important.  <a
href="../user-classifications.html#merge-meister">Merge Meisters</a>
who do multi-thousand file merges stress this.</p>

</div>  <!-- automated-merge -->

</div>  <!-- requirements -->


<div class="h3" id="related-documents">
<h3>Related Documents and Discussion</h3>

<p>TODO: Many of these documents should be consolidated into the
requirements, functional, and design specification pages of this Merge
Tracking area.  Others may be better off linked from the
functional/design spec pages.</p>

<ul>
  <li><a href="summit.html">CollabNet Enterprise customer summit on
  Merge Tracking</a></li>

  <li><a
  href="http://svn.collab.net/repos/svn/trunk/notes/schema-tradeoffs.txt"
  >schema-tradeoffs.txt</a>: Search for the section called "Questions
  that Users Ask".</li>

<!-- TODO: "Import" from Karl's site:
  <li><a href="merge-history/threads.html">Various merging threads
  from dev@svn</a></li>

  <li><a href="jackr-diff-merge-syntax/threads.html">Mail from Jack
  Repenning about diff/merge syntax</a></li>
-->
  <li><a
  href="http://thread.gmane.org/gmane.comp.version-control.revctrl/2"
  >Bram Cohen describes Codeville's merge algorithm</a></li>

  <li><a
  href="http://lists.zooko.com/pipermail/revctrl/2005-May/000012.html"
  >Bram Cohen muses on rename/copy, etc</a></li>
</ul>

</div>  <!-- related-documents -->

</div>  <!-- h2 -->
</body>
</html>
