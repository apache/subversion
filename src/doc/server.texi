@node Server
@chapter Server

@c Ben is hacking on this.

The @dfn{Subversion server} isn't a simple, monolithic daemon process
like sshd or ftpd; rather, it's a set of well-defined interface layers
that is meant to be flexible and open to future innovations.

However, please remember that after all is said and done, it's
@emph{Apache} that is the actual Subversion server process; all of the
lower layers are simply shared libraries running in Apache's address
space!

In a nutshell:

@enumerate
@item
    Apache receives a Subversion-specific HTTP method request.
@item
    An appropriate Apache module handles the request, and makes calls
    into the "main" Subversion library.
@item
    The "main" library interacts with an abstract, versioned filesystem
    and returns a response.
@item
    The Apache module converts this response back into an HTTP response
    to be sent to the client.
@end enumerate


To build our concepts cleanly, we'll explore the server-side of
Subversion from the bottom up.  (For full diagram, @xref{Architecture}.)

@example

 +------+-------------+--+---------+-------+ <===== Server interface
 |                                         |
 |            Main SVN Library             |
 |                                         |
 +-----------------------------------------+ <===== Filesystem interface
 |                                         |
 |          Subversion Filesystem          |
 |                                         |
 +-+--------------+--------+---------+-----+ <===== Database interface
   | Berkeley DBM |        |   SQL   |
   +--------------+        +---------+

@end example

@menu
* Database::                  Putting the information on disk.
* Filesystem::                The low-level Subversion Filesystem.
* Deltas::                    Subversion's way of describing changes.
* Locking::                   How read/write locks work in the Filesystem.
* Main Library::              The highest-level server interface.
* Apache::                    The actual server process.
@end menu

@c ----------------------------------------------------------------

@node Database
@section Database

At the bottom of our design, we require a way of storing information on
disk.  More specifically, we need @dfn{transactions}.

A @dfn{transaction} is a term that refers to a set of modifications made
to a database; however, these modifications behave as a @emph{single
unit} of change.  Specifically,

@enumerate
@item
   If a transaction succeeds, the database recognizes a single unit of
   work as having been performed.  (And if the database allows you to
   "undo" the work, the entire set of changes is undone as a unit.)
@item
   If some portion of the transaction fails (for either logical or
   hardware-crash reasons), then the @emph{entire}
   transaction fails, and no changes are made at all.  The database is
   guaranteed to remain in a good, consistent state.
@end enumerate

This inability to divide the set of changes is known as @dfn{atomicity},
and is the critical concept behind transactions.

Subversion's @dfn{database interface} (@dfn{svn_db.h}), therefore, is a
simple API for reading and writing information to any sort of disk-based
system that supports transactions.  The Subversion Filesystem
(@xref{Filesystem}.)  is the only library that depends on this
interface.

@c OK, guys, this is tricky to specify.  This requires a good knowledge
@c of Berkeley DBM's API, SQL, and database API's in general!  What's
@c written here is a simplification of a typical DBM API:

@table @code
@item svn_db_init ()
   tell the database to initialize itself
@item svn_db_open (path)
   open a particular database file (or object)
@item svn_db_close (db)
   close a database file (or object)
@item svn_db_txn_begin (db, *txn_id)
   start a transaction, receiving transaction_id
@item svn_db_put (db, *txn_id, *key, *value)
   write a key/value pair into the database
@item svn_db_get (db, *txn_id, *key, *value)
   read a key/value pair from the database
@item svn_db_del (db, *txn_id, *key)
   remove a key/value pair from the database
@item svn_db_txn_commit (db, *txn_id)
   commit the transaction
@item svn_db_txn_abort (db, *txn_id)
   abort the transaction in progress
@end table

For the initial release of Subversion, we will probably use the
open-source Berkeley DBM library.  (For information, see
@uref{http://www.sleepycat.com, Sleepycat Software}.)

In the future, of course, contributors are free to write libraries that
implement this same API on top of a more powerful SQL system.


@c ----------------------------------------------------------------

@node Filesystem
@section Filesystem

The @dfn{Subversion Filesystem} (abbreviated: @dfn{svn_fs}) gives us an
abstract way of thinking about the way files are stored and versioned,
independent of the actual means of storage.

Like any typical UNIX-like filesystem, files are stored in a tree.
However, while CVS uses the actual UNIX filesystem to store items, the
svn_fs implements files and directories as database objects
(@xref{Database}.)

To begin, please be sure that you're already casually familiar with
Subversion's ideas of files, directories, and version histories.  If
not, @xref{Model}.

For completeness, we can now offer a precise, technical description of
these terms.  Here is the schema used by svn_fs:

@c This is taken from jimb's very first Subversion spec!
@c <jimb> -----------------------------

@quotation

A @dfn{text string} is a string of Unicode characters which is
canonically decomposed and ordered, according to the rules described in
the Unicode standard.

A @dfn{string of bytes} is what you'd expect.

A @dfn{property list} is an ordered list of properties.  A
@dfn{property} is a pair @code{(@var{name}, @var{value})}, where
@var{name} is a text string, and @var{value} is a string of bytes.

A @dfn{file} is a property list and a string of bytes.

A @dfn{node} is either a file or a directory.  (We define a directory
below.)  Nodes are distinguished unions --- you can always tell whether
a node is a file or a directory.

A @dfn{node table} is an array mapping some set of positive integers,
called @dfn{node numbers}, onto @dfn{nodes}.  If a node table maps some
number @var{i} to some node @var{n}, then @var{i} is a @dfn{valid node
number} in that table, and @dfn{node @var{i}} is @var{n}.  Otherwise,
@var{i} is an @dfn{invalid node number} in that table.

A @dfn{directory entry} is a triple @code{(@var{name}, @var{props},
@var{node})}, where @var{name} is a text string, @var{props} is a
property list, and @var{node} is a node number.

A @dfn{directory} is an unordered list of directory entries.

A @dfn{version} is a node number and a property list.

A @dfn{history} is an array of versions, indexed by a contiguous range
of positive integers containing 1.

A @dfn{repository} consists of node table and a history.

@end quotation
@c  </jimb> ----------------------


@subsection Properties

(expound) A note on properties:  they're stored as a bytestream that's
simply appended to a file's text.  Need common routines to decode/encode
them.  To fetch a list of @emph{all} of a file

Also, it's important to remember that properties aren't only attached to
files;  they're attached to directory entries and versions too.

@table @code
@item read_node_prop (version, path, propname)
@itemx write_node_prop (version, path, propname)
 read/write a particular property of a file or directory entry
@item read_version_prop (version, propname)
@itemx write_version_prop (version, propname)
 read/write a particular property of a version-history (such as a log)
@end table


@subsection Deltas

(expound) A @dfn{delta} object is a specific data structure used by the
Subversion server and client.  It's used to do stuff.

@table @code
@item delta (versionA, pathA, versionB, pathB)
 return a delta object (which converts subtree A into subtree B)
@end table

@subsection Reading Filesystem Information

Here are functions to retrieve information from the filesystem.

@table @code
@item latest ()
 returns the latest global version of the repository
@item read (version, path)
 if path is a file, return full text (which includes property stream);@*
 if path is a directory, return list of directory entries.
@end table

@subsection Writing Filesystem Information

@table @code
@item submit (delta)
 ask filesystem's lock manager for approval of delta; returns token (or
failure)
@item write (delta, token)
 actually write the delta into the filesystem
@item abandon (token)
 tell lock manager that the delta will @emph{not} be written (despite
 previous approval)
@end table

For a fuller description of write-locking, @xref{Locking}.

@c ----------------------------------------------------------------

@node Deltas
@section Deltas


@c ----------------------------------------------------------------

@node Locking
@section Locking

The Subversion Filesystem has a locking mechanism built into it.

The locking system was designed to have these features:

@enumerate
@item
    There can any number of concurrent filesystem @dfn{readers}, and a
    reader never has to wait for any other process.
@item
    There can any number of concurrent filesystem @dfn{writers},
    provided that their changes do not directly conflict.  When writers
    @emph{do} need to wait, the waiting is kept to an absolute minimum.
@end enumerate

@subsection Read Locks

Reading is easy; if a server process wants to execute a @code{read()}
call into the filesystem, it goes right through.  The design of the
versioning filesystem (@xref{Model}.) allows a reader to simply skip
down the version history, locate the correct "root" node, and then
follow the particular tree downwards to the file or directory it wishes
to read.  Any number of readers can follow this algorithm without
interfering with another; and because writers don't link to the version
history until they're finished writing everything, there's no way for a
reader to accidentally stumble upon an unfinished tree.

@subsection Write Locks

Each Subversion filesystem has a process called a @dfn{lock manager}.
The lock manager isn't always running;  when a server process wishes to
execute a @code{write()} on the filesystem, it must first determine if a
lock manager is running.  If not, it starts one.

@example

                  D              /
                   \            /
                    \          /
                     |        /
                     v       /
       +--------------------|--------------+
       |                    v              |
       |             Approved?             |
       |                |                  |
       |                |                  |
       |                v                  |
       |          Concurrency Pool         |
       |       +--------------------+      |
       |       |     D            D |      |
       |       |  D        D   D    |      |
       |       +--------------------+      |
       +-----------------------------------+

@end example

After the lock manager is up, the server process first sends it a
@code{submit()} call containing the delta it would like to write.

The lock manager contains a pool of "approved changes".  This pool is a
set of deltas which have been okayed for concurrent application to the
filesystem.  After receiving a delta from @code{submit()}, the lock
manager determines if it is safe to apply the new delta at the same time
as the other ones in progress.@footnote{This rule is actually quite
simple:  a set of deltas may be concurrently written @emph{if and only
if} the order in which they are applied does not matter!}

If the lock manager decides that the requested delta conflicts with
other deltas being applied at that moment, it returns a failure to the
server, and the server must wait and try again with another
@code{submit()} request.

If the lock manager decides that the requested delta does not conflict,
it returns a transaction token to the server.  The server then uses this
token to execute a @code{write()} on the filesystem.

After the @code{write()} is completed, the delta is removed from the
lock manager's concurrency pool, and the server closes its connection.

When the lock manager has no more open server connections, it dies.




@c ----------------------------------------------------------------

@node Main Library
@section Main Library






