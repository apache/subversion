<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- originated from English revision 10817 -->
<appendix id="svn-ap-a">
  <title>Subversion para usuarios de CVS</title>

  <simplesect>

    <para>Este apéndice es una guía para usuarios de CVS nuevos en
      Subversion. Es esencial una lista de diferencias entre los dos
      sistemas <quote>visto desde 10,000 pies de alto</quote><!--TODO:
      viewed from 10,000 feet-->. Para cada sección, proporcionaremos
      cuando sea posible enlaces<!--TODO:backreferences--> a los
      capítulos relevantes.</para>

    <para>Aunque el fín de Subversion es <!--TODO:is to take over the current
      and future CVS user base-->asumir el control de la base actual
      y futura de los usuarios de CVS, algunas nuevas características
      y cambios de diseño fueron requeridos para arreglar ciertos
      comportamientos <quote>rotos</quote> que tenía CVS. Esto
      significa que, como usuario de CVS, puede necesitar romper
      hábitos&mdash;unos que usted olvidó...<!--TODO:ones that you
      forgot were odd to begin with-->.</para>

  </simplesect>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 1 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ap-a-sect-1">
    <title>Los números de revisión son diferentes ahora</title>

    <para>En CVS, los números de revisión son por-fichero. Esto es porque
      CVS usa RCS como motor de program<!--TODO:as a backend-->; cada
      fichero tiene su correspondiente fichero RCS en el repositorio,
      y el repositorio se representa<!--TODO:repository is roughly laid
      out according to the structure--> aproximadamente según la
      estructura de su árbol de proyecto.</para>

    <para>En Subversion, el repositorio parece un solo sistema de
      ficheros. Cada envío tiene como resultado<!--TODO:Each commit
      results in an entirely new filesystem-->un nuevo árbol de
      sistema de ficheros entero; en esencia, el repositorio es un
      array de árboles. Cada uno de estos árboles se etiqueta con un
      solo número de revisión. Cuando alguien habla sobre la
      <quote>revisión 54</quote>, ellos están hablando sobre un
      árbol particular (e indirectamente, la forma que el sistema
      de ficheros tenía despues del envío
      54<!--TODO:54th commit-->).</para>

    <para>Técnicamente, no es válido hablar sobre la <quote>revisión
      5 de <filename>foo.c</filename></quote>. En su lugar, uno diría
      <quote><filename>foo.c</filename> como aparece en la revisión
      5</quote>. También, tenga cuidado cuando haga supuestos sobre
      la evolución de un fichero. En CVS, las revisiones 5 y 6 de
      <filename>foo.c</filename> son siempre diferentes. En Subversion,
      es más probable que <filename>foo.c</filename>
      <emphasis>no</emphasis> haya cambiado entre las revisiones 5 y
      6.</para>

    <para>Para más detalles sobre este asunto, vea <xref
    linkend="svn-ch-2-sect-3.2" />.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 2 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ap-a-sect-2">
    <title>Versiones de directorios</title>
    
    <para>Subversion sigue estructura de árbol<!--TODO:Subversion tracks
      tree structures-->, no solo el contenido de ficheros. Es una de las
      razones más grandes por las que Subversion fue escrito para
      reemplazar CVS.</para>

    <para>Esto es lo que significa para usted, como anterior usuario
      de CVS:</para>

    <itemizedlist>
      <listitem>
        <para>Los comandos <command>svn add</command> y <command>svn
          delete</command> trabajan ahora sobre directorios, tal como
          trabajan sobre ficheros. Así que haga <command>svn copy</command>
          y <command>svn move</command>. Sin embargo, estos comandos
          <emphasis>no</emphasis> causan ningún tipo de cambio
          inmediato en el repositorio. En su lugar, los objetos de la
          copia de trabajo simplemente se planifican para la adición
          o la eliminación. No sucede ningún cambio en el repositorio
          hasta que ejecute <command>svn commit</command>.</para>
      </listitem>
      <listitem>
        <para>Los directorios no serán contenedores estupidos nunca más;
          tienen número de revisión como los ficheros. (O más
          correctamente, es correcto hablar sobre <quote>directorio
          <filename>foo/</filename> en la revisión 5</quote>.)</para>
      </listitem>
    </itemizedlist>

    <para>Vamos<!--TODO:Let's talk... o es mejor decir "hablaremos"?-->
      a hablar más sobre este último punto. El versionado de directorios
      es un duro problema; porque queremos permitir <!--TODO:
      mixed-revision working copies-->copias de trabajo con revisiones
      mezcladas, hay algunas limitaciones en cómo podemos<!--TODO:
      on how far we can abuse-->abusar de este modelo.</para>

    <para>Desde un punto de vista teórico, definimos <quote>revisión
      5 del directorio <filename>foo</filename></quote> para significar
      una colección específica de directorios-entradas y características.
      Ahora suponga que empezamos a añadir y a quitar ficheros de
      <filename>foo</filename>, y luego envíamos el cambio. Sería una
      mentira decir que todavía tenemos la revisión 5 de
      <filename>foo</filename>. Sin embargo, si vemos <!--TODO:
      if we bumped <filename>foo</filename>'s revision number-->el número
      de revisión de <filename>foo</filename> despues del envío,
      tambien sería esto una mentira; puede haber otros cambios en
      <filename>foo</filename> que todavía no hayamos recibido, porque
      no hemos actualizado todavia.</para>
    
    <para>Subversion trata este problema siguiendo silenciosamente
      <!--TODO:by quietly tracking committed adds and deletes-->
      las agregaciones y las eliminaciones enviadas en el área
      <filename>.svn</filename>. Cuando usted ejecuta finalmente
      <command>svn update</command>, todas las cuentas se fijan
      <!--TODO:are settled--> con el repositorio, y el nuevo número
      de revisión se fija correctamente. <emphasis>Por lo tanto,
      solamente después de una actualización es verdaderamente
      seguro decir que usted tiene una revisión <quote>perfecta</quote>
      de un directorio.</emphasis> La mayoría del tiempo, su copia
      de trabajo contendrá revisiones <quote>imperfectas</quote> del
      directorio.</para>
    
    <para>Similarmente, un problema surge si usted intenta enviar
      <!--TODO:property changes on a directory--> cambios de las
      caracteristicas de un directorio. Normalmente, el envío
      <!--TODO:would bump--> chocaría con  el número local de revisión
      del directorio de trabajo. Pero otra vez, eso sería una mentira,
      porque puede haber añadidos<!--TODO:adds or deletes--> o
      eliminaciones que el directorio todavía no tiene, porque no ha
      habido ninguna actualización. <emphasis>Por lo tanto, usted no
      tiene<!--TODO:you are not allowed--> permiso para enviar
      cambios-características<!--TODO:property-changes--> sobre un
      directorio a menos que el directorio esté
      actualizado.</emphasis></para>

    <para>Para más discusión sobre las limitaciones del versionado de
      directorios, vea <xref linkend="svn-ch-2-sect-3.4"/>.</para>

  </sect1>


  <!-- ================================================================= -->
  <!-- ======================== SECTION 3 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ap-a-sect-3">
    <title>Más operaciones estando desconectado</title>
    <!--More Disconnected Operations-->

    <para>En años recientes, ha llegado a ser <!--TODO:outrageously cheap-->
      muy barata y abundante, pero el ancho de banda de red no. Por lo
      tanto, la copia de trabajo se Subversion ha sido optimizada alrededor
      del recurso más escaso.</para>

    <para>El directorio administrativo <filename>.svn</filename> tiene el
      mismo proposito que el directorio <filename>CVS</filename>, excepto
      que este también almacena copias <quote>pristinas</quote> de
      solo-lectura de sus ficheros. Esto le permite hacer muchas cosas
      desconectado:</para>
    
    <variablelist>
      
      <varlistentry>
        <term><command>svn status</command></term>
        <listitem>
          <para>Le muestra cualquier cambio local que haya hecho (vea <xref
              linkend="svn-ch-3-sect-4.3.1"/>)</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>svn diff</command></term>
        <listitem>
          <para>Le muestra los detalles de sus cambios (vea <xref
              linkend="svn-ch-3-sect-4.3.2"/>)</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><command>svn revert</command></term>
        <listitem>
          <para>Borra sus cambios locales (vea <xref
              linkend="svn-ch-3-sect-4.3.3"/>)</para>
        </listitem>
      </varlistentry>

    </variablelist>

    <para>También, los ficheros prístinos almacenados permiten al cliente
      de Subversion enviar las diferencias al repositorio<!--TODO:client
      to send differences when committing-->, lo que CVS no puede
      hacer.</para>

    <para>El último subcomando en la lista es nuevo; este no solo borrará
      las modificaciones locales, sino que desprogramará
      <!--TODO: un-schedule-->las operaciones tales como adiciones y
      eliminaciones. Es la manera preferida para revertir un fichero;
      ejecutando <command>rm file; svn update</command> seguirá funcionando,
      pero empaña el propósito de actualización<!--TODO:it blurs the
      purpose of updating-->. Y, mientras nosotros estamos en este
      asunto&hellip;

    </para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 4 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ap-a-sect-4">
    <title>Distinciones entre estado (status) y actualización (update)</title>

    <para>En Subversion, hemos intentado eliminar muchas de las confusiones
      entre los comandos <command>cvs status</command> y
      <command>cvs update</command>.</para>

    <para>El comando <command>cvs status</command> tiene dos propositos:
      primero, mostrarle al usuario cualquier modificación local en la
      copia de trabajo, y segundo, mostrarle al usuario qué ficheros
      están desactualizados. Desafortunadamente, debido a la dificil de
      leer salida de estado<!--TODO:status output-->, muchos usuarios de
      CVS no se aprobechan del todo de este comando. En cambio, han
      desarrollado el habito de ejecutar <command>cvs update</command>
      o <command>cvs update -n</command> para ver rapidamente sus
      modificaciones. Si los usuarios olvidan usar la opción
      <option>-n</option>, esto tiene el efecto secundario de combinar
      cambios del repositorio que no están preparados<!--TODO:this has the
      side effect of merging repository changes they may not be ready
      to deal with-->.</para>

    <para>Con Subversion, hemos intentado eliminar este desorden haciendo
      la salida de <command>svn status</command> facil de leer para los
      humanos y los programas de análisis sintacticos<!--TODO:parsers-->.
      También, <command>svn update</command> solo imprime información
      sobre los ficheros que están actualizados, <emphasis>no</emphasis>
      sobre modificaciones locales.</para>

    <para><command>svn status</command> imprime todos los ficheros que
      tienen modificaciones locales. Por defecto, no se contacta con el
      repositorio<!--TODO:the repository is not contacted...eso de "el
      repositorio no es contactado" no queda muy bien-->. Mientras
      este subcomando acepta un número justo de opciones, los siguientes
      son los usados más comúnmente:</para>

    <variablelist>
      <varlistentry>
        <term><option>-u</option></term>
        <listitem>
          <para>Contacta con el repositorio para determinar, y después
            mostrar, la información más desactualizada<!--TODO:
            out-of-dateness information-->.</para>
        </listitem>
      </varlistentry>
      
      <varlistentry>
        <term><option>-v</option></term>
        <listitem>
          <para>Muestra <emphasis>todas</emphasis> las entradas bajo
            el control de versiones.</para>
        </listitem>
      </varlistentry>

      <varlistentry>
        <term><option>-N</option></term>
        <listitem>
          <para>Se ejecuta no-recursivamente (no desciende hacia los
            subdirectorios).</para>
        </listitem>
      </varlistentry>
    </variablelist>

    <para>El comando <command>status</command> tiene dos formatos de
      salida. En el formato <quote>corto</quote> por defecto, las
      modificaciones locales se parecen a esto:</para>

    <screen>
% svn status
M     ./foo.c
M     ./bar/baz.c
</screen>

    <para>Si usted especifica la opción <option>--show-updates</option>
      (<option>-u</option>), <!--TODO:a longer output format is
      used-->un formato de salida más largo es usado:</para>

    <screen>
% svn status -u
M             1047    ./foo.c
       *      1045    ./faces.html
       *         -    ./bloo.png
M             1050    ./bar/baz.c
Status against revision:   1066
</screen>

    <para>En este caso, aparecen dos columnas nuevas. La segunda columna
      contiene un asterisco si el fichero o directorio está desactualizado.
      La tercera columna muestra el número de revisión del objeto en la
      copia de trabajo. En el ejemplo de arriba, el asterisco indica que
      <filename>faces.html</filename> será parcheado si actualizamos, y
      que <filename>bloo.png</filename> es un nuevo fichero añadido
      en el repositorio. (El <command>-</command> al lado de
      <filename>bloo.png</filename> significa que todavía no existe en
      la copia de trabajo.)</para>

    <!-- ###TODO describe -u here as well as -uv. -u and -v use
         different <quote>long</quote> formats and need to be
         documented separately. Moreover, as you can combine -u and
         -v, it needs to be explained what each of them does. As -u is
         much more important than -v, and the example following that
         paragraph *is* about -u, not -v, my patch concentrated on
         that. -->

    <para>Por último<!--TODO:lastly-->, aquí está un resumen rápido de
      los códigos de estado más comunes que usted puede ver:</para>

    <screen>
A    Resource is scheduled for Addition
D    Resource is scheduled for Deletion
M    Resource has local modifications
C    Resource has conflicts (changes have not been completely merged
       between the repository and working copy version)
X    Resource is external to this working copy (comes from another
       repository.  See <xref linkend="svn-ch-7-sect-2.3.6" />)
?    Resource is not under version control
!    Resource is missing or incomplete (removed by another tool than
       Subversion)
</screen>

    <!-- ###TODO:  This paragraph should be moved elsewhere.  We are
                   talking about status codes here, and not update.
                   Although CVS uses update as a form of status... -->
    <para>Subversion ha combinado los codigos de CVS <command>P</command>
      y <command>U</command> en<!--TODO:into just--> <command>U</command>.
      Cuando ocurre una fusión o un conflicto, Subversion simplemente
      imprime <command>G</command> o <command>C</command>, antes que
      una oración entera sobre esto<!--TODO:rather than a whole sentence
      about it-->.</para>

    <para>Para una discusión más detallada sobre <command>svn
    status</command>, vea <xref linkend="svn-ch-3-sect-4.3.1" />.</para>


  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 5 ============================= -->
  <!-- ================================================================= -->
  <sect1 id="svn-ap-a-sect-5">
    <title>Ramas y etiquetas</title>

    <para>Subversion no distingue entre el espacio del sistema de
      ficheros y el espacio de <quote>rama</quote>; las ramas y
      etiquetas son directorios ordinarios dentro del sistema de
      ficheros. Ésta es probablemente la única gran valla mental
      que un usuario de CVS tiene que superar. Lea todo sobre esto
      en <xref linkend="svn-ch-4"/>.</para>


    <warning>
      <para>Puesto que Subversion trata las ramas y etiquetas como
        directorios ordinarios, recuerde siempre descargar el directorio
        <literal>trunk</literal>
        (<literal>http://svn.example.com/repos/calc/trunk/</literal>)
        de su proyecto, y no el proyecto en si mismo<!--TODO:itself-->
        (<literal>http://svn.example.com/repos/calc/</literal>). Si
        comete el error de descargar el proyecto en sí mismo, obtendrá
        una copia<!--TODO:you'll wind up with a working copy that contains
        a copy--> de trabajo que contendrá una copia de su proyecto
        para cada rama y etiqueta que tenga.<footnote><para>Esto es,
        <!--TODO:providing you don't run out of disk space before
        your checkout finishes....no tengo ni idea de como traducirlo-->
        proporcionando no ejecute hacia afuera el espacio en disco
        antes de que su descarga finalice.</para> </footnote></para>
    </warning>

  </sect1>


  <!-- ================================================================= -->
  <!-- ======================== SECTION 6 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ap-a-sect-6">
    <title>Propiedades de los metadatos</title>

    <para>Una característica nueva de Subversion es que usted puede
      unir metadatos arbitrarios (o <quote>propiedades</quote>) a
      ficheros y directorios. Las propiedades son pares arbitrarios
      nombre/valor asociados con ficheros y directorios en su copia
      de trabajo.</para>
    
    <para>Para fijar u obtener un nombre de propiedad, use los
      subcomandos <command>svn propset</command> y
      <command>svn propget</command>. Para enumerar todas las
      propiedades de un objeto, use <command>svn proplist</command>.
    </para>

    <para>Para más información, vea <xref linkend="svn-ch-7-sect-2"/>.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 7 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ap-a-sect-7">
    <title>Resolución de conflictos </title>

    <para>CVS marca conflictos en linea con <quote>marcas de
      conflicto</quote>, e imprime una <command>C</command>
      durante la actualización. Historicamente, esto ha causado
      promlemas, porque CVS no está haciendo bastante. Muchos
      usuarios se olvidan (o no ven) la <command>C</command>
      después de que <!--TODO:after it whizzes by on their terminal-->
      esta silbe en sus terminales. Se olvidan a menudo de que las
      marcas de conflicto están incluso presentes, y después
      accidentalmente envian los ficheros conteniendo las marcas
      de conflicto.</para>

    <para>Subversion solventa este problema haciendo los conflictos
      más tangibles. Recuerde que un fichero está en estado de
      conflicto, y no permitirá que envie sus cambios hasta que
      ejecute <command>svn resolved</command>.  Vea <xref
      linkend="svn-ch-3-sect-4.4"/> para más detalles.</para>
  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 8 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ap-a-sect-8">
    <title>Ficheros binarios y traducción</title>

    <para>En el sentido más general, Subversion maneja ficheros
      binarios más elegantemente que CVS. Porque CVS usa RCS, solo
      puede almacenar copias completas sucesivas de un fichero
      binario que cambia. Pero internamente, Subversion expresa
      diferencias entre ficheros usando un algoritmo de
      diferenciador de binarios<!--TODO:binary-differencing-->,
      sin importar si contienen datos o datos binarios. Esto
      significa que todos los ficheros son almacenados
      diferenciados<!--TODO:differentially--> (comprimidos) en el
      repositorio, y las pequeñas diferencias son siempre enviadas
      a traves <!--TODO:over the network...a traves o sobre la red?-->
      de la red.</para>
    
    <para>Los usuarios de CVS tienen que marcar los ficheros binarios con
      los parámetros <option>-kb</option>, para evitar que los datos sean
      mutilados (debido a la traducción de la expansión de la palabra
      clave y del final de linea<!--TODO:due to keyword expansion and
      line-ending translations-->. A veces se olvidan de hacerlo.</para>

    <para>Subversion toma la ruta más paranoica: primero, nunca realiza
      ningún tipo de traducción de la palabra clave  o del fin de linea
      a menos que usted le diga explicitamente que lo haga (vea <xref
      linkend="svn-ch-7-sect-2.3.4"/> y <xref
      linkend="svn-ch-7-sect-2.3.5"/> para más detalles). Por defecto,
      Subversion trata todos los datos del ficheros como una cadena
      literal de bytes, y los ficheros son siempre guardados en el
      repositorio en un estado sin traducir.</para>

    <para>Segundo, Subversion mantiene una noción interna de si un
      fichero es <quote>texto</quote> o datos <quote>binarios</quote>,
      pero esta noción es <emphasis>solamente</emphasis> existente
      en la copia de trabajo. Durante un <command>svn update</command>,
      Subversion realizará fusiones contextuales<!--TODO:contextual
      merges... fusiones de texto--> en ficheros de texto modificados
      localmente, pero no intentará hacer eso para los ficheros
      binarios.</para>

    <para>Para determinar si es posible una fusión de contexto,
      Subversion examina la propiedad <literal>svn:mime-type</literal>.
      Si el fichero no tiene la propiedad <literal>svn:mime-type</literal>,
      o tiene un mime-type que es textual (e.j. <literal>text/*</literal>),
      Subversion asume que es texto. Si no, Subversion asume que el
      fichero es binario. Subversion también ayuda a los usuarios
      ejecutando un algoritmo de detección de binarios en los comandos
      <command>svn import</command> y <command>svn add</command>. Estos
      comandos harán una buena conjetura y despues (posiblemente) fije
      una propiedad <literal>svn:mime-type</literal> binaria en el
      fichero que es agregado. (Si Subversion supone mal, el usuario
      siempre puede borrar o editar a mano la propiedad.)</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 9 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ap-a-sect-9">

    <title>Versioned Modules</title>

    <para>Unlike CVS, a Subversion working copy is aware that it has
      checked out a module.  That means that if somebody changes the
      definition of a module, then a call to <command>svn update</command>
      will update the working copy appropriately.</para>

    <para>Subversion defines modules as a list of directories within a
      directory property:  see <xref linkend="svn-ch-7-sect-3"/>.</para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 10 ============================= -->
  <!-- ================================================================= -->
  <sect1 id="svn-ap-a-sect-10">

    <title>Authentication</title>

    <para>With CVS's pserver, you are required to <quote>login</quote>
      to the server before any read or write operation&mdash;you even
      have to login for anonymous operations.  With a Subversion
      repository using Apache HTTPD as the server, you don't provide
      any authentication credentials at the outset&mdash;if an
      operation that you perform requires authentication, the server
      will challenge you for your credentials (whether those
      credentials are username and password, a client certificate, or
      even both).  So if your repository is world-readable, you will
      not be required to authenticate at all for read
      operations.</para>

    <para>As with CVS, Subversion still caches your credentials on
      disk (in your <filename>~/.subversion/auth/</filename>
      directory) unless you tell it not to by using the
      <option>--no-auth-cache</option> switch.</para>



  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 11 ============================= -->
  <!-- ================================================================= -->
  <sect1 id="svn-ap-a-sect-11">

    <title>Converting a Repository from CVS to Subversion</title>

    <para>Perhaps the most important way to familiarize CVS users with
      Subversion is to let them continue to work on their projects
      using the new system.  And while that can be somewhat
      accomplished using a flat import into a Subversion repository of
      an exported CVS repository, the more thorough solution involves
      transferring not just the latest snapshot of their data, but all
      the history behind it as well, from one system to another.  This
      is an extremely difficult problem to solve that involves
      deducing changesets in the absence of atomicity, and translating
      between the systems' completely orthogonal branching policies,
      among other complications.  Still, there are a handful of tools
      claiming to at least partially support the ability to convert
      existing CVS repositories into Subversion ones.</para>

    <para>One such tool is cvs2svn (<systemitem
      class="url">http://cvs2svn.tigris.org/</systemitem>), a Python
      script originally created by members of Subversion's own
      development community.  Others include Chia-liang Kao's
      Subversion converter plugin to the VCP tool (<systemitem
      class="url">http://svn.clkao.org/revml/branches/svn-perl/</systemitem>)
      and Lev Serebryakov's RefineCVS (<systemitem
      class="url">http://lev.serebryakov.spb.ru/refinecvs/</systemitem>).
      These tools have various levels of completeness, and may make
      entirely different decisions about how to handle your CVS
      repository history.  Whichever tool you decide to use, be sure
      to perform as much verification as you can stand on the
      conversion results&mdash;after all, you've worked hard to build
      that history!</para>

    <para>For an updated collection of links to known converter tools,
      visit the Links page of the Subversion website (<systemitem
      class="url">http://subversion.tigris.org/project_links.html</systemitem>).</para>

  </sect1>

</appendix>

<!--
local variables: 
sgml-parent-document: ("book.xml" "appendix")
end:
-->
