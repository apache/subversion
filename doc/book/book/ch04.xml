<!-- This chapter is slated for mass rewriting.  If you're adding
     content or fixing things, please understand that your changes,
     while certainly influencing the resultant chapter, might
     themselves get lost in the mix. -->
<chapter id="svn-ch-4">
<title>Branching and Merging</title>

  <simplesect>

    <para>Branching, tagging, and merging are concepts common to
      almost all version control systems.  If you're not familiar with
      these ideas, we provide a good introduction in this chapter.  If
      you are familiar, then hopefully you'll find it interesting to
      see how Subversion implements these ideas.</para>

    <para>Branching is a fundamental part of version control.  If
      you're going to allow Subversion to manage your data, then this
      is a feature you'll eventually come to depend on.  This chapter
      assumes that you're already familiar with Subversion's basic
      concepts (<xref linkend="svn-ch-2"/>).</para>

  </simplesect>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 1 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-1">
    <title>What's a branch?</title> 

    <para>Suppose it's your job to maintain a document for a division
      in your company, a handbook of some sort.  One day a different
      division asks you for the same handbook, but with a few parts
      'tweaked' for them, since they do things slightly
      differently.</para>

    <para>What do you do in this situation?  You do the obvious thing:
      you make a second copy of your document, and begin maintaining
      the two copies separately.  As each department asks you to make
      small changes, you incorporate them into one copy or the
      other.</para>

    <para>You often want to make the same change to both copies.  For
      example, if you discover a typo in the first copy, it's very
      likely that the same typo exists in the second copy.  The two
      documents are almost the same, after all; they only differ in
      small, specific ways.</para>

    <para>This is the basic concept of a <firstterm>branch</firstterm>
      &mdash; namely, a line of development that exists independently of
      another line, yet still shares a common history if you look far
      enough back in time.  A branch always begins life as a copy of
      something, and moves on from there, generating its own
      history.</para>

      <figure id="svn-ch4-dia1">
        <title>Branches of development</title>
        <graphic fileref="images/ch04dia1.png"/>
      </figure>

    <para>Subversion has commands to help you maintain parallel
      branches of your files and directories.  It allows you to create
      branches by copying your data, and remembers that the copies are
      related to one another.  It also helps you duplicate changes
      from one branch to another.  Finally, it can make portions of
      your working copy reflect different branches, so that you can
      "mix and match" different lines of development in your daily
      work.</para>

  </sect1>
  
  <!-- ================================================================= -->
  <!-- ======================== SECTION 2 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-2">
    <title>Using branches</title> 

    <para>At this point, you should understand how each commit creates
      an entire new filesystem tree (called a "revision") in the
      repository.  If not, go back and read about revisions in  <xref
      linkend="svn-ch-2-sect-3.2"/>.</para>

    <para>For this chapter, we'll go back to the same example from
      Chapter 2.  Remember that you and your collaborator, Sally, are
      sharing a repository that contains two projects,
      <filename>paint</filename> and <filename>calc.</filename>
      Notice, however, that this time somebody has created two new
      top-level directories in the repository, called
      <filename>trunk</filename> and <filename>branches</filename>.
      The projects themselves are subdirectories of
      <filename>trunk</filename>, which we'll explain later on.</para>
    
      <figure id="svn-ch4-dia2">
        <title>Starting repository layout</title>
        <graphic fileref="images/ch04dia2.png"/>
      </figure>

    <para>As before, assume that you and Sally both have working
      copies of the <filename>/trunk/calc</filename> project.</para>

    <para>Let's say that you've been given the task of performing a
      radical reorganization of the project.  It will take a long time
      to calc, and will affect all the files in the project.  The
      problem here is that you don't want to interfere with Sally, who
      is in the process of fixing small bugs here and there.  She's
      depending on the fact that the latest version of the project is
      always usable.  If you start committing your changes bit-by-bit,
      you'll surely break things for Sally.</para>

    <para>One strategy is to crawl into a hole: you and Sally can stop
      sharing information for a week or two.  That is, start gutting
      and reorganizing all the files in your working copy, but don't
      commit or update until you're completely finished with the task.
      There are a number of problems with this, though.  First, it's
      not very safe.  Most people like to save their work to the
      repository frequently, should something bad accidentally happen
      to their working copy.  Second, it's not very flexible.  If you
      do your work on different computers (perhaps you have a working
      copy of <filename>/trunk/calc</filename> on two different
      machines), you'll need to manually copy your changes back and
      forth, or just do all the work on a single computer.  Finally,
      when you're finished, you might find it very difficult to commit
      your changes.  Sally (or others) may have made many other
      changes in the repository that are difficult to merge into your
      working copy -- especially all at once.</para>

    <para>The better solution is to create your own branch, or line of
      development, in the repository.  This allows you to save your
      half-broken work frequently without interfering with others, yet
      you can still selectively share information with your
      collaborators.  You'll see exactly how this works later
      on.</para>

  <sect2 id="svn-ch-4-sect-2.1">
    <title>Creating a branch</title> 
      
      <para>Creating a branch is very simple -- you make a copy of the
        project in the repository using the <command>svn
        copy</command> command.  Subversion is not only able to copy
        single files, but whole directories as well.  In this case,
        you want to make a copy of the
        <filename>/trunk/calc</filename> directory.  Where should the
        new copy live?  Whereever you wish -- it's a matter of project
        policy.  Let's say that your team has a policy of creating
        branches in the <filename>/branches/calc</filename> area of
        the repository, and you want to name your branch
        "my-calc-branch".  You'll want to create a new directory,
        <filename>/branches/calc/my-calc-branch</filename>, which
        starts as a copy of <filename>/trunk/calc</filename>. </para>

      <para>There are two different ways to make a copy.  We'll
        demonstrate the messy way first, just to make the concept
        clear.  To begin, check out a working copy of the root
        (<filename>/</filename>) of the repository:</para>

<screen>
$ svn checkout http://svn.example.com/repos bigwc
A  bigwc/branches/
A  bigwc/branches/calc
A  bigwc/branches/paint
A  bigwc/trunk/
A  bigwc/trunk/calc
A  bigwc/trunk/calc/Makefile
A  bigwc/trunk/calc/integer.c
A  bigwc/trunk/calc/button.c
A  bigwc/trunk/paint
A  bigwc/trunk/paint/Makefile
A  bigwc/trunk/paint/canvas.c
A  bigwc/trunk/paint/brush.c
Checked out revision 340.
</screen>

      <para>Making a copy is now simply a matter of passing two
        working-copy paths to the <command>svn copy</command>
        command:</para>

<screen>
$ cd bigwc
$ svn copy trunk/calc branches/calc/my-calc-branch
$ svn status
A  +   branches/calc/my-calc-branch
</screen>

      <para>In this case, the <command>svn copy</command> command
        recursively copies the <filename>trunk/calc</filename>
        working directory to a new working directory,
        <filename>branches/calc/my-calc-branch</filename>.  As you
        can see from the <command>svn status</command> command, the
        new directory is now scheduled for addition to the repository.
        But also notice the + sign next to the letter A.  This
        indicates that the scheduled addition is a
        <emphasis>copy</emphasis> of something, not something new.
        When you commit your changes, Subversion will create
        <filename>/branches/calc/my-calc-branch</filename> in the
        repository by copying <filename>/trunk/calc</filename>,
        rather than resending all of the working copy data over the
        network:</para>

<screen>
$ svn commit -m "Creating a private branch of /trunk/calc."
Adding      branches/calc/my-calc-branch
Committed revision 341.
</screen>

      <para>And now the easier method of creating a branch, which we
        should have told you about in first place: <command>svn
        copy</command> is able to operate on two URLs.</para>

<screen>
$ svn copy http://svn.example.com/repos/trunk/calc \
           http://svn.example.com/repos/branches/calc/my-calc-branch \
      -m "Creating a private branch of /trunk/calc"

Committed revision 341.
</screen>

      <para>There's really no difference between these two methods.
        Both procedures create a new directory in revision 341, and
        the new directory is a copy of
        <filename>/trunk/calc</filename>.  Notice that the second
        method, however, performs an <emphasis>immediate</emphasis>
        commit.  It's an easier procedure, because it doesn't require
        you to check out a large mirror of the repository.  In fact,
        this technique doesn't even require you to have a working copy
        at all.</para>
      
      <figure id="svn-ch4-dia3">
        <title>Repository with new copy</title>
        <graphic fileref="images/ch04dia3.png"/>
      </figure>
      
      <sidebar>
        <title>Cheap copies</title>
                
        <para>Subversion's repository has a clever design.  When you
          copy a directory, you don't need to worry about the
          repository growing huge -- Subversion doesn't actually
          duplicate any data.  Instead, it creates a new directory
          entry that points to an <emphasis>existing</emphasis> tree.
          If you're a Unix user, this is the same concept as a
          hard-link.  From there, the copy is said to be "lazy".  That
          is, if you commit a change to one file within the copied
          directory, then only that file changes -- the rest of the
          files continue to exist as links to the original files in
          the original directory.</para>
      
        <para>This is why you'll often hear Subversion users talk
          about "cheap copies".  It doesn't matter how large the
          directory is -- it takes a very tiny, constant amount of
          time to make a copy of it.  In fact, this feature is the
          basis of how commits work in Subversion: each revision is a
          "cheap copy" of the previous revision, with a few items
          lazily changed within.  (To read more about this, visit
          Subversion's website and read about the "bubble up" method
          in Subversion's design documents.)</para>

        <para>The point here is that copies are cheap, both in time
          and space.  Make branches as often as you want. </para>
      </sidebar>

    </sect2>
    
    <sect2 id="svn-ch-4-sect-2.2">
      <title>Working with your branch</title> 

      <para>Now that you've created a new branch of the project, you
        can check out a new working copy to start using it:</para>

<screen>
$ svn checkout http://svn.example.com/repos/branches/calc/my-calc-branch
A  my-calc-branch/Makefile
A  my-calc-branch/integer.c
A  my-calc-branch/button.c
Checked out revision 341.
</screen>

      <para>There's nothing special about this working copy; it simply
        mirrors a different location of the repository.  When you
        commit changes, however, Sally won't ever see them when she
        updates.  Her working copy is of
        <filename>/trunk/calc</filename>.</para>

      <para>Let's pretend that a week goes by, and the following
      commits happen:</para>

      <itemizedlist>
        <listitem><para>
          You make a change to
          <filename>/branches/calc/my-calc-branch/button.c</filename>,
          which creates revision 342.</para>
        </listitem>

        <listitem><para>
          You make a change to
          <filename>/branches/calc/my-calc-branch/integer.c</filename>,
          which creates revision 343.</para>
        </listitem>

        <listitem><para>
          Sally makes a change to
          <filename>/trunk/calc/integer.c</filename>, which creates
          revision 344.</para>
        </listitem>
      </itemizedlist>

      <para>There are now two independent lines of development
        happening on <filename>integer.c</filename>:</para>

      <figure id="svn-ch4-dia4">
        <title>The branching of one file's history</title>
        <graphic fileref="images/ch04dia4.png"/>
      </figure>

      <para>Things get interesting when you look at the history of
        changes made to your copy of
        <filename>integer.c</filename>:</para>

<screen>
$ pwd
/home/user/my-calc-branch

$ svn log integer.c
------------------------------------------------------------------------
rev 343:  user | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines

* integer.c:  frozzled the wazjub.

------------------------------------------------------------------------
rev 303:  sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines

* integer.c:  changed a docstring.

------------------------------------------------------------------------
rev 98:  sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines

* integer.c:  adding this file to the project.

------------------------------------------------------------------------
</screen>

      <para>Notice that Subversion is tracing the history of your
      <filename>integer.c</filename> all the way back through time,
      traversing the point where it was copied.  (Remember that your
      branch was created in revision 341.)  Now look what happens when
      Sally runs the same command on her copy of the file:</para>

<screen>
$ pwd
/home/sally/calc

$ svn log integer.c
------------------------------------------------------------------------
rev 344:  sally | 2002-11-07 15:27:56 -0600 (Thu, 07 Nov 2002) | 2 lines

* integer.c:  fix a bunch of spelling errors.

------------------------------------------------------------------------
rev 303:  sally | 2002-10-29 21:14:35 -0600 (Tue, 29 Oct 2002) | 2 lines

* integer.c:  changed a docstring.

------------------------------------------------------------------------
rev 98:  sally | 2002-02-22 15:35:29 -0600 (Fri, 22 Feb 2002) | 2 lines

* integer.c:  adding this file to the project.

------------------------------------------------------------------------
</screen>

      <para>Sally sees her own revision 344 change, but not the change
      you made in revision 343.  As far as Subversion is concerned,
      these two commits affected different files in different
      repository locations.  However, Subversion
      <emphasis>does</emphasis> show that the two files share a common
      history.  Before the branch-copy was made in revision 341, they
      used to be the same file.  That's why you and Sally both see
      revisions 303 and 98.</para>

    </sect2>

    <sect2 id="svn-ch-4-sect-2.3">
      <title>The moral of the story</title> 

      <para>There are two important lessons that you should remember
      from this section.</para>

      <orderedlist>
        <listitem>
          <para>Unlike many other version control systems,
            Subversion's branches exist a <emphasis>normal filesystem
            directories</emphasis> in the repository, not in some
            extra dimension.</para>
        </listitem>
        <listitem>
          <para>Subversion has no internal concept of a "branch"
          &mdash; only copies.  When you copy a directory, the
          resulting directory is only a "branch" because
          <emphasis>you</emphasis> attach that meaning to it.  You may
          think of the directory differently, or treat it differently,
          but to Subversion it's just an ordinary directory that
          happens to have been created by copying.</para>
        </listitem>
      </orderedlist>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 3 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-3">
    <title>Copying changes between branches</title>
      
    <para>Now you and Sally are working on parallel branches of the
      project.  The good news is that you're not interfering with each
      other.  The bad news is that it's very easy to drift
      <emphasis>too</emphasis> far apart.  Remember that one of the
      problems with the "crawl in a hole" strategy is that by the time
      you're finished with your branch, it may be near-impossible to
      merge your changes back into the main branch without a huge
      number of conflicts.</para>

    <para>Instead, you and Sally should continue to share changes as
      you work.  It's up to you to decide which changes are worth
      sharing; Subversion gives you the ability to selectively "copy"
      changes between branches.</para>

    <para>In the previous section, we mentioned that both you and
      Sally made changes to <filename>integer.c</filename> on
      different branches.  If you look at Sally's log message for
      revision 344, you can see that she fixed some spelling errors.
      No doubt, your copy of the same file still has the same spelling
      errors.  It's likely that your future changes to this file will
      be affecting the same areas that have the spelling errors, so
      you're in for some potential conflicts when you merge your
      branches someday.  It's better, then, to receive Sally's change
      now, <emphasis>before</emphasis> you start working too heavily
      in the same places.</para>

    <para>It's time to use the <command>svn merge</command> command.
      This command, it turns out, is a very close cousin to the
      <command>svn diff</command> command (which you read about in
      Chapter 3).  Both commands are able to compare any two objects
      in the repository and describe the differences.  For example,
      you can ask <command>svn diff</command> to show you the exact
      change made by Sally in revision 344:</para>

<screen>
$ svn diff -r343:344 http://svn.example.com/repos/trunk/calc

Index: integer.c
===================================================================
--- integer.c	(revision 343)
+++ integer.c	(revision 344)
@@ -147,7 +147,7 @@
     case 6:  sprintf(info->operating_system, "HPFS (OS/2 or NT)"); break;
     case 7:  sprintf(info->operating_system, "Macintosh"); break;
     case 8:  sprintf(info->operating_system, "Z-System"); break;
-    case 9:  sprintf(info->operating_system, "CPM"); break;
+    case 9:  sprintf(info->operating_system, "CP/M"); break;
     case 10:  sprintf(info->operating_system, "TOPS-20"); break;
     case 11:  sprintf(info->operating_system, "NTFS (Windows NT)"); break;
     case 12:  sprintf(info->operating_system, "QDOS"); break;
@@ -164,7 +164,7 @@
     low = (unsigned short) read_byte(gzfile);  /* read LSB */
     high = (unsigned short) read_byte(gzfile); /* read MSB */
     high = high &lt;&lt; 8;  /* interpret MSB correctly */
-    total = low + high; /* add them togethe for correct total */
+    total = low + high; /* add them together for correct total */
 
     info->extra_header = (unsigned char *) my_malloc(total);
     fread(info->extra_header, total, 1, gzfile);
@@ -241,7 +241,7 @@
      Store the offset with ftell() ! */
 
   if ((info->data_offset = ftell(gzfile))== -1) {
-    printf("error: ftell() retturned -1.\n");
+    printf("error: ftell() returned -1.\n");
     exit(1);
   }
 
@@ -249,7 +249,7 @@
   printf("I believe start of compressed data is %u\n", info->data_offset);
   #endif
   
-  /* Set postion eight bytes from the end of the file. */
+  /* Set position eight bytes from the end of the file. */
 
   if (fseek(gzfile, -8, SEEK_END)) {
     printf("error: fseek() returned non-zero\n");
</screen>
      
    <para>The <command>svn merge</command> is almost exactly the same.
      Instead of printing the differences to your terminal, however,
      it applies them directly to your working copy as <emphasis>local
      modifications</emphasis>:</para>
    
<screen>
$ svn merge -r343:344 http://svn.example.com/repos/trunk/calc
U  integer.c

$ svn status
M  integer.c
</screen>

    <para>The output of <command>svn merge</command> shows that your
      copy of <filename>integer.c</filename> was patched.  It now
      contains Sally's change &mdash; it has been "copied" from her
      branch to your working copy, and now exists as a local
      modification.  At this point, it's up to you to review the local
      modification and make sure it works correctly.</para>

    <para>In another scenario, it's possible that things may not have
      gone so well, and that <filename>integer.c</filename> may have
      entered a conflicted state.  You might need to resolve the
      conflict using standard procedures (see Chapter 3), or if you
      decide that the merge was a bad idea altogether, simply give up
      and <command>svn revert</command> the local change.</para>

    <para>But assuming the you've reviewed the merged change, you can
      <command>svn commit</command> the change as usual.  At that
      point, the change has been merged into your repository branch.
      In version control terminology, this act of copying changes
      between branches is commonly called
      <firstterm>porting</firstterm> changes.</para>

    <sidebar>
      <title>Why not use patches instead?</title>

      <para>A question may be on your mind, especially if you're a
        Unix user: why bother to use <command>svn merge</command> at
        all?  Why not simply use the operating system's
        <command>patch</command> command to accomplish the same job?
        For example:</para>

<screen>
$ svn diff -r343:344 http://svn.example.com/repos/trunk/calc > patchfile
$ patch -p0  &lt; patchfile
Patching file integer.c using Plan A...
Hunk #1 succeeded at 147.
Hunk #2 succeeded at 164.
Hunk #3 succeeded at 241.
Hunk #4 succeeded at 249.
done
</screen>

      <para>In this particular case, yes, there really is no
        difference.  But <command>svn merge</command> has special
        abilities that surpass the <command>patch</command> program.
        The file format used by <command>patch</command> is quite
        limited; it's only able to tweak file contents.  There's no
        way to represent changes to <emphasis>trees</emphasis>, such
        as the addition, removal, or renaming of files and
        directories.  If Sally's change had, say, added a new
        directory, the output of <command>svn diff</command> wouldn't
        have mentioned it at all.  <command>svn diff</command> only
        outputs the limited patch-format, so there are some ideas it
        simply can't express. 
        <footnote> <para>In the future, the Subversion project plans
          to use (or invent) an expanded patch format that
          describes tree-changes.</para>
        </footnote>
        The <command>svn merge</command> command, however, can express
        tree-changes by directly applying them to your working
        copy.</para>

      </sidebar>

    <para>A word of warning: while <command>svn diff</command> and
      <command>svn merge</command> are very similar in concept, they
      do have different syntax in many cases.  Be sure to read about
      them in Chapter 8 for details, or ask <command>svn
      help</command>.  For example, <command>svn merge</command>
      requires a working-copy path as a target, i.e. a place where it
      should apply the tree-changes.  If the target isn't specified,
      it assumes you want the changes applied to the current working
      directory.  If you want changes applied somewhere else, you'll
      need to say so:</para>

<screen>
$ svn merge -r343:344 http://svn.example.com/repos/trunk/calc my-calc-branch
U   my-calc-branch/integer.c
</screen>

      <!-- ### fix the damn left arrow quoting problem in both screen
      examples -->
    
    <sect2 id="svn-ch4-sect-3.1">
      <title>The repeated merge problem</title>

      <para>Merging changes sounds simple enough, but in practice it
        can become a headache.  The problem is that if you repeatedly
        merge changes from one branch to another, you may accidentally
        merge the same change <emphasis>twice</emphasis>.  When this
        happens, sometimes things will work fine.  When patching a
        file, Subversion typically notices if the file already has the
        change, and does nothing.  But if the already-existing change
        has been modified in any way, you'll get a conflict.  Ideally,
        Subversion would automatically prevent applying changes more
        than once.</para>

      <para>This is a problem that plagues many version control
        systems, including both CVS and Subversion.  For now, the only
        way to avoid this problem in Subversion is to carefully keep
        track of which changes have been merged, and which haven't.
        When you create a branch directory, you need to track what
        revision it was created in &mdash; make a note somewhere to
        yourself.  When you merge a revision (or range of revisions)
        into your working copy, you'll need to remember them as well.
        If you forget any of this information, you can rediscover it
        by examining the output of <command>svn log -v
        branch-dir</command>.  But the point is that each subsequent
        merge needs to be carefully constructed by hand, making sure
        that previously-merged revisions aren't re-merged
        again.</para>

      <para>Of course, Subversion has plans to solve this problem
        sometime after release 1.0.  All of this merging information
        can be tracked in property metadata (see <xref
        linkend="svn-ch-6-sect-2"/>), and thus Subversion will someday
        be able to automatically avoid repeated merges.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 4 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-4">
    <title>Removing a change from the repository</title>

    <para>A common use for <command>svn merge</command> is to roll
      back a change that has already been committed.  Suppose you
      decide that the change made way back in revision 303, which
      changed <filename>integer.c</filename>, is completely wrong.
      It never should have been committed.  You can use <command>svn
      merge</command> to "undo" the change in your working copy, and
      then commit the local modification to the repository.  All you
      need to do is do specify a <emphasis>reverse</emphasis>
      difference:</para>

<screen>
$ svn merge -r 303:302 http://svn.example.com/trunk/calc
U  integer.c

$ svn status
M  integer.c

$ svn commit -m "Undoing change committed in r303."
Sending    integer.c
Transmitting file data .
Committed revision 350.
</screen>

    <para>One way to think about a repository revision is as a
      specific group of changes (some version control systems call
      these <firstterm>changesets</firstterm>).  By using the
      <option>-r</option> switch, you can ask <command>svn
      merge</command> to apply a changeset, or whole range of
      changesets, to your working copy.  In our case of undoing a
      change, we're asking <command>svn merge</command> to apply
      changeset #303 to our working copy
      <emphasis>backwards</emphasis>.</para>
    
    <para>Keep in mind that rolling back a change like this is just
      like any other <command>svn merge</command> operation, so you
      should use <command>svn status</command> and <command>svn
      diff</command> to confirm that your work is in the state you
      want it to be in, and then use <command>svn commit</command> to
      send the final version to the repository.  After committing,
      this particular changeset is no longer reflected in the HEAD
      revision.</para>

    <para>Again, you may be thinking: well, that really didn't undo
      the commit, did it?  The change still exists in revision 303.
      If somebody checks out a version of the
      <filename>calc</filename> project between revisions 303 and
      349, they'll still see the bad change, right?</para>

    <para>Yes, that's true.  When we talk about "removing" a change,
      we're really talking about "removing it from HEAD".  The
      original change still exists in the repository's history.  For
      most situations, this is good enough.  Most people are only
      interested in tracking the HEAD of a project anyway.  There are
      special cases, however, where you really might want to destroy
      all evidence of the commit.  (Perhaps somebody accidentally
      committed a confidential document.)  This isn't so easy, it
      turns out, because Subversion was deliberately designed to never
      lose information.  Revisions are immutable trees which build
      upon one another.  Removing a revision from history would cause
      a domino effect, creating chaos in all subsequent revisions and
      possibly invalidating all working copies.
      <footnote> 
        <para>The Subversion project has plans, however, to
        someday implement an <command>svnadmin obliterate</command>
        command that would accomplish the task of permanently deleting
        information.</para> 
      </footnote>
    </para>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 5 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-5">
    <title>Switching a working copy</title>

    <para> The <command>svn switch</command> command transforms an
      existing working copy into a different branch.  While this
      command isn't strictly necessary for working with branches, it
      provides a nice shortcut to users.  In our earlier example,
      after creating your private branch, you checked out a fresh
      working copy of the new repository directory.  Instead, you can
      simply ask Subversion to change your working copy of
      <filename>/trunk/calc</filename> to mirror the new branch
      location:</para>

<screen>
$ cd calc

$ svn info | grep Url
Url: http://svn.example.com/trunk/calc

$ svn switch http://svn.example.com/branches/calc/my-calc-branch
U   integer.c
U   button.c
U   Makefile
Updated to revision 341.

$ svn info | grep Url
Url: http://svn.example.com/branches/calc/my-calc-branch
</screen>

    <para>After "switching" to the branch, your working copy is no
      different than what you would get from doing a fresh checkout of
      the directory.  And it's usually more efficient to use this
      command, because often branches only differ by a small degree.
      The server sends only the minimal set of changes necessary to
      make your working copy reflect the branch.</para>

    <para>Of course, most projects are more complicated than our
      <filename>calc</filename> example.  Users often create a branch
      of a project's subdirectory, and then use <command>svn
      switch</command> to move that specific subdirectory in their
      working copy to the new branch.  Or sometimes users will only
      switch a single working file to a branch.  That way, they can
      continue to receive normal updates to most of their working
      copy, but the "switched" portions will remain immune (unless
      someone commits a change to their branch).  This feature adds a
      whole new dimension to the concept of a "mixed working copy" &mdash;
      not only can working copies contain a mixture of working
      revisions, but a mixture of repository locations as well.</para>
    
    <para>If your working copy contains a number of switched subtrees
      from different repository locations, it continues to function as
      normal.  When you update, you'll receive patches to each subtree
      as appropriate.  When you commit, your local changes will still
      be applied as a single, atomic change to the repository.</para>

    <para>A final note:  while it's okay for your working copy to
      reflect a mixture of repository locations, these locations
      must all be within the <emphasis>same</emphasis> repository.
      Subversion repositories aren't yet able to communicate with one
      another;  that's a feature planned beyond Subversion 1.0.</para>
    
    <sidebar>
      <title>Switches and updates</title>
      
      <para>Have you noticed that the output of <command>svn
          switch</command> and <command>svn update</command> look the
        same?  The switch command is actually a superset of the
        update command.</para>

      <para>When you run <command>svn update</command>, you're asking
        the repository to compare two trees.  The repsository does so,
        and then sends a description of the differences back to the
        client. The only difference between <command>svn
        switch</command> and <command>svn update</command> is that the
        update command always compares two identical paths.</para>
      
       <para>That is, if your working copy is a mirror of
        <filename>/trunk/calc</filename>, then <command>svn
        update</command> will automatically compare your working copy
        of <filename>/trunk/calc</filename> to
        <filename>/trunk/calc</filename> in the HEAD revision.  If
        you're switching your working copy to a branch, then
        <command>svn switch</command> will compare your working copy
        of <filename>/trunk/calc</filename> to some
        <emphasis>other</emphasis> branch-directory in the HEAD
        revision.</para>

      <para>In other words, an update moves your working copy through
        time.  A switch moves your working copy through time
        <emphasis>and</emphasis> space.</para>
    </sidebar>

  </sect1>


  <!-- ================================================================= -->
  <!-- ======================== SECTION 6 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-6">
    <title>Tags</title>

    <para>Another common version control concept is a
      <firstterm>tag</firstterm>.  A tag is just a "snapshot" of a
      project in time.  In Subversion, this idea already seems to be
      everywhere.  Each repository revision is exactly that &mdash; a
      snapshot of the filesystem after each commit.</para>

    <para>However, people often want to give more human-friendly names
      to tags, like "release-1.0".  And they want to make snapshots of
      smaller subdirectories of the filesystem.  After all, it's not
      so easy to remember that release-1.0 of a piece of software is a
      particular subdirectory of revision 4822.</para>

    <sect2 id="svn-ch-4-sect-6.1">
      <title>Creating a simple tag</title>

      <para>Once again, <command>svn copy</command> comes to the
        rescue.  If you want to create a snapshot of
        <filename>/trunk/calc</filename> exactly as it looks in the
        HEAD revision, then make a copy of it:</para>

<screen>
$ svn copy http://svn.example.com/repos/trunk/calc \
           http://svn.example.com/repos/tags/calc/release-1.0 \
      -m "Tagging the 1.0 release of the 'calc' project."

Committed revision 351.
</screen>

      <para>This example assumes that a
        <filename>/tags/calc</filename> directory already exists.
        After the copy completes, the new
        <filename>release-1.0</filename> directory is forever a
        snapshot of how the project looked in the HEAD revision at the
        time you made the copy.  Of course you might want to be more
        precise about exactly which revision you copy, in case
        somebody else may have committed changes to the project when
        you weren't looking.  So if you know that revision 350 of
        <filename>/trunk/calc</filename> is exactly the snapshot you
        want, you can specify it by passing <option>-r350</option>
        to the <command>svn copy</command> command.</para>

      <para>But wait a moment: isn't this tag-creation procedure the
        same procedure we used to create a branch?  Yes, in fact, it
        is.  In Subversion, there's no difference between a tag and a
        branch.  Both are just ordinary directories that are created
        by copying.  Just as with branches, the only reason a copied
        directory is a "tag" is because <emphasis>humans</emphasis>
        have decided to treat it that way: as long as nobody ever
        commits to the directory, it forever remains a snapshot.  If
        people start committing to it, it becomes a branch.</para>

      <para>If you are administering a repository, there are two
        approaches you can take to managing tags.  The first approach
        is "hands off": as a matter of project policy, decide where
        your tags will live, and make sure all users know how to treat
        the directories they copy in there.  (That is, make sure they
        know not to commit to them.)  The second approach is more
        paranoid: you can use one of the access-control scripts
        provided with Subversion to prevent anyone from doing anything
        but creating new copies in the tags-area (###cross-ref a
        section that demonstrates how to use these scripts?).  The
        paranoid approach, however, isn't usually necessary.  If a
        user accidentally commits a change to a tag-directory, you can
        simply undo the change as discussed in the previous section.
        This is version control, after all.</para>

    </sect2>
    
    <sect2 id="svn-ch-4-sect-6.2">
      <title>Creating a complex tag</title>
      
      <para>Sometimes you may want your "snapshot" to be more
        complicated than a single directory at a single
        revision.</para>
      
      <para>For example, pretend your project is much larger than our
        <filename>calc</filename> example: suppose it contains a
        number of subdirectories and many more files.  In the course
        of your work, you may decide that you need to create a working
        copy that is designed to have specific features and bugfixes.
        You can accomplish this by selectively pinning files or
        directories at particular revisions (using <command>svn update
        -r</command> liberally), or by switching files and directories
        to particular branches (making use of <command>svn
        switch</command>).  When you're done, your working copy is a
        hodgepodge of repository locations from different revisions.
        But after testing, you know it's the precise combination of
        data you need.</para>

      <para>Time to make a snapshot.  Copying one URL to another won't
        work here. In this case, you want to make a snapshot of your
        exact working copy arrangement and store it in the repository.
        Luckily, the <command>svn copy</command> actually has four
        different uses (which you can read about in Chapter 8),
        including the ability to copy a working-copy tree to the
        repository:</para>

<screen>
$ ls
./    ../   my-working-copy/

$ svn copy my-working-copy http://svn.example.com/repos/tags/calc/newtag

Committed revision 352.
</screen>

      <para>Now there is a new directory in the repository,
        <filename>/tags/calc/mytag</filename>, which is an exact
        snapshot of your working copy &mdash; mixed revisions, urls,
        and all.</para>

      <para>Other users have found interesting uses for this feature.
        Sometimes there are situations where you have a bunch of local
        changes made to your working copy, and you'd like a
        collaborator to see them.  Instead of running <command>svn
        diff</command> and sending a patchfile (which won't capture
        tree changes), you can instead use <command>svn copy</command>
        to "upload" your working copy to a private area of the
        repository.  Your collaborator can then either checkout a
        verbatim copy of your working copy, or use <command>svn
        merge</command> to receive your exact changes.</para>

    </sect2>

  </sect1>

  <!-- ================================================================= -->
  <!-- ======================== SECTION 7 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-7">
    <title>Branch maintenance</title>

    <para>You may have noticed by now that Subversion is extremely
      flexible.  Because it implements branches and tags with the same
      underlying mechanism (directory copies), and because branches
      and tags appear in normal filesystem space, many people find
      Subversion intimidating.  It's almost <emphasis>too</emphasis>
      flexible.  In this section, we'll offer some suggestions for
      arranging and managing your data over time.</para>

    <sect2 id="svn-ch4-sect7.1">
      <title>Repository layout</title>
      
      <para>There are some standard, recommended ways to organize a
        repository.  Most people create a <filename>trunk</filename>
        directory to hold the "main line" of development, a
        <filename>branches</filename> directory to contain branch
        copies, and a <filename>tags</filename> directory to contain
        tag copies.  If a repository holds only one project, then
        often people create these top-level directories:</para>

<screen>
/trunk
/branches
/tags
</screen>

      <para>If a repository contains multiple projects, people often
        index their layout by branch:</para>

<screen>
/trunk/paint
/trunk/calc
/branches/paint
/branches/calc
/tags/paint
/tags/calc
</screen>

    <para>...or by project:</para>

<screen>
/paint/trunk
/paint/branches
/paint/tags
/calc/trunk
/calc/branches
/calc/tags
</screen>

      <para>Of course, you're free to ignore these common layouts.  You
        can create any sort of variation, whatever works best for you or
        your team.  Remember that whatever you choose, it's not a
        permanent commitment.  You can reorganize your repository at any
        time.  Because branches and tags are ordinary directories, the
        <command>svn mv</command> command can move or rename them
        however you wish.  Switching from one layout to another is just
        a matter of issuing a series of server-side moves; if you don't
        like the way things are organized in the repository, just juggle
        the directories around.</para>
      
    </sect2>
    
    <sect2 id="svn-ch4-sect7.2">
      <title>Data lifetimes</title>

      <para>Another nice feature of Subversion's model is that
        branches and tags can have finite lifetimes, just like any
        other versioned item.  For example, suppose you eventually
        finish all your work on your personal branch of the
        <filename>calc</filename> project.  After merging all of your
        changes back into <filename>/trunk/calc</filename>, there's
        no need for your private branch directory to stick around
        anymore:</para>

<screen>
$ svn remove http://svn.example.com/repos/branches/calc/my-calc-branch \
             -m "Removing obsolete branch of calc project."

Committed revision 375.
</screen>

      <para>And now your branch is gone.  Of course it's not really
        gone: the directory is simply missing from the HEAD revision,
        no longer distracting anyone.  If you look at an earlier
        revision (by means of <command>svn checkout -r</command>,
        <command>svn switch -r</command>, or <command>svn list
        -r</command>), you'll still be able to see your old
        branch.</para>

      <para>If browsing your deleted directory isn't enough, you can
        always bring it back.  Resurrecting data is very easy in
        Subversion.  If there's a deleted directory (or file) that
        you'd like to bring back into HEAD, simply use <command>svn
        copy -r</command> to copy it from the old revision:</para>

<screen>
$ svn copy -r374 http://svn.example.com/repos/branches/calc/my-calc-branch \
                 http://svn.example.com/repos/branches/calc/my-calc-branch

Committed revision 376.
</screen>

      <para>In our example, your personal branch had a relatively
        short lifetime: you may have created it to fix a bug or
        implement a new feature.  When your task is done, so is the
        branch.  In software development, though, it's also common to
        have two "main" branches running side-by-side for very long
        periods.  For example, suppose it's time to release a stable
        <filename>calc</filename> project to the public, and you know
        it's going to take a couple of months to shake bugs out of the
        software.  You don't want people to add new features to the
        project, but you don't want to tell all developers to stop
        programming either.  So instead, you create a "stable" branch
        of the software that won't change much:</para>

<screen>
$ svn cp http://svn.example.com/repos/trunk/calc \
         http://svn.example.com/branches/calc/stable-1.0
         -m "Creating stable branch of calc project."

Committed revision 377.
</screen>

      <para>And now developers are free to continue adding
        cutting-edge (or experimental) features to
        <filename>/trunk/calc</filename>, and you can declare a
        project policy that only bugfixes are to be committed to
        <filename>/branches/calc/stable-1.0</filename>.  That is, as
        people continue to work on the trunk, a human selectively
        ports bugfixes over to the stable branch.  Even after the
        stable branch has shipped, you'll probably continue to
        maintain the branch for a long time &mdash; that is, as long
        as you continue to support that release for customers.</para>

    </sect2>

  </sect1>


  <!-- ================================================================= -->
  <!-- ======================== SECTION 8 ============================== -->
  <!-- ================================================================= -->
  <sect1 id="svn-ch-4-sect-8">
    <title>Summary</title>

    <para>We've covered a lot of ground in this chapter.  We've
      discussed the concepts of tags and branches, and demonstrated
      how Subversion implements these concepts by copying directories
      with the <command>svn copy</command> command.  We've shown how
      to use <command>svn merge</command> to copy changes from one
      branch to another, or roll back bad changes.  We've gone over
      the use of <command>svn switch</command> to create
      mixed-location working copies.  And we've talked about how one
      might manage the organization and lifetimes of branches in a
      repository.</para>

    <para>Remember the Subversion mantra: branches are cheap.  So use
      them liberally!</para>

  </sect1>

</chapter>

<!--
local variables: 
sgml-parent-document: ("book.xml" "chapter")
end:
-->


