<!-- This chapter is slated for mass rewriting.  If you're adding
     content or fixing things, please understand that your changes,
     while certainly influencing the resultant chapter, might
     themselves get lost in the mix. -->
<chapter id="svn-ch-5">
<title>Repository Administration</title>

  <simplesect>

    <para>The Subversion repository is the central storehouse of
      versioned data for any number of projects.  In this chapter,
      we'll discuss:</para>

    <itemizedlist>
      <listitem>
        <para>creation and configuration of a repository.</para>
      </listitem>
      <listitem>
        <para>networking of repositories.</para>
      </listitem>
      <listitem>
        <para>repository maintainance, including the use of the
          <command>svnlook</command> and <command>svnadmin</command>
          tools provided with Subversion.</para>
      </listitem>
      <listitem>
        <para>suggestions for how to arrange the versioned data in
          your repository.</para>
      </listitem>
      <listitem>
        <para>common questions and mistakes regarding repostories.</para>
      </listitem>
    </itemizedlist>

  </simplesect>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 1:  REPOSITORY CREATION AND CONFIGURATION           *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-5-sect-1">
    <title>Repository Creation and Configuration</title>

    <para>Creating a Subversion repository is incredibly simple.  The
      <command>svnadmin</command> utility, provided with Subversion,
      has a subcommand for doing just that.  To create a new
      repository, just run:</para>
          
    <screen>
$ svnadmin create path/to/repos
</screen>
          
    <para>This creates a new repository in a subdirectory
      <filename>repos</filename>.  This new repository begins life
      at revision 0, which is defined to consist of nothing but the
      top-level root (<filename>/</filename>) filesystem directory.
      Revision 0 also has a single revision property,
      <literal>svn:date</literal>, set to the time at which the
      repository was created.</para>
          
    <para>You may have noticed that the path argument to
      <command>svnadmin</command> was just a regular filesystem path
      and not a URL like the <command>svn</command> client program
      uses when referring to repositories.  Both
      <command>svnadmin</command> and <command>svnlook</command> are
      considered server-side utilities&mdash;they are used on the
      machine where the repository resides to examine or modify
      aspects of the repository, and are in fact unable to perform
      tasks across a network.  A common mistake made by Subversion
      newcomers is trying to pass URLs (even "local"
      <literal>file:</literal> ones) to these two programs</para>

    <para>We mentioned previously that <command>svnadmin</command>
      creates repositories in a subdirectory, the basename of the path
      passed to the command.  Let's take a peek at what is actually
      created inside that subdirectory.</para>
            
    <screen>
$ ls repos
conf/  dav/  db/  format  hooks/  locks/  README
</screen>
      
    <para>The following is a brief description of what all those
      items in our new repository directory are:</para>

    <variablelist>
      <varlistentry>
        <term>conf</term>
        <listitem>
          <para>Currently unused; repository-side config files
            will go in this directory someday.</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>dav</term>
        <listitem>
          <para>A directory provided to Apache and mod_dav_svn for
            their private housekeeping data.</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>db</term>
        <listitem>
          <para>The main Berkeley DB environment, full of DB tables
            that comprise the data store for libsvn_fs.  This is
            where all of your version data resides.</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>format</term>
        <listitem>
          <para>A file whose contents are a single integer value
            that dictates the version number of the repository
            layout.</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>hooks</term>
        <listitem>
          <para>A directory full of hook script templates (and hook
            scripts themselves, once you've installed some).</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>locks</term>
        <listitem>
          <para>A directory for Subversion's repository locking
            data, used for tracking accessors to the
            repository.</para>
        </listitem>
      </varlistentry>
     <varlistentry>
        <term>README</term>
        <listitem>
          <para>A file which merely informs its readers that they
            are looking at a Subversion repository.</para>
        </listitem>
      </varlistentry>
    </variablelist>
      
    <para>In general, you'll not want to tamper with most of the items
      in your repository, at least not <quote>by hand</quote>.  The
      <command>svnadmin</command> tool should be sufficient for any
      changes necessary to your repository, or you can look to
      third-party tools (such as Berkeley DB's tool suite) for
      tweaking relevant subsections of the repository.  Some
      exceptions exist, though, and we'll cover those here.</para>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-1.1">
      <title>Hook scripts</title>

      <para>A <firstterm>hook</firstterm> is a program triggered by
        some repository event, such as the creation of a new revision
        or the modification of an unversioned property.  Each hook is
        handed enough information to tell what that event is, what
        target(s) it's operating on, and the username of the person
        who triggered the event.  Depending on the hook's output or
        return status, the hook program may continue the action, stop
        it, or suspend it in some way.</para>
            
      <para>The <filename>hooks</filename> subdirectory is, by
        default, filled with templates for various repository
        hooks.</para>
            
      <screen>
$ ls repos/hooks/
post-commit.tmpl          pre-revprop-change.tmpl  write-sentinels.tmpl
post-revprop-change.tmpl  read-sentinels.tmpl
pre-commit.tmpl           start-commit.tmpl
</screen>
            
      <para>There is one template for each hook that the Subversion
        repository implements, and by examining the contents of those
        template scripts, you can see what triggers each such script
        to run and what data is passed to that script.  Also present
        in many of these templates are examples of how one might use
        that script, in conjunction with other Subversion-supplied
        programs, to perform common useful tasks.  To actually install
        a working hook, you need only place some executable program or
        script into the <filename>repos/hooks</filename> directory
        which can be execute as the name (like
        <command>start-commit</command> or
        <command>post-commit</command>) of the hook.</para>

      <para>On Unix platforms, this means supplying a script or
        program (which could be a shell script, a Python program, a
        compiled C binary, or any number of other things) named
        exactly like the name of the hook.  Of course, the template
        files are present for more than just informational
        purposes&mdash;the easiest way to install a hook on Unix
        platforms is to simply copy the appropriate template file to a
        new file that lacks the <literal>.tmpl</literal> extension,
        and then customize the hooks contents.  Windows, however, uses
        file extensions to denote executability, so you would need to
        supply a program whose basename is the name of the hook plus
        one of the special extensions recognized by Windows for
        executable programs, such as <filename>.exe</filename> or
        <filename>.com</filename> for programs, and
        <filename>.bat</filename> for batch files.</para>
          
      <para>Currently there are five true hooks implemented by the
        Subversion repository.  The following is a brief description
        of how each of those works:</para>

      <variablelist>
        <varlistentry>
          <term><filename>start-commit</filename></term>
          <listitem>
            <para>This is run before the committer's transaction is
              even created.  It is typically used to decide if the
              user has commit privileges at all.  The repository
              passes two arguments to this program:  the path to the
              repository, and username which is attempting the commit.
              If the program returns a non-zero exit value, the commit
              is stopped before the transaction is even created.</para>
          </listitem>
        </varlistentry>
            
        <varlistentry>
          <term><filename>pre-commit</filename></term>
          <listitem>
            <para>This is run when the transaction is complete, but
              before it is committed.  Typically, this hook is used to
              protect against commits that are disallowed due to
              content or location (for example, your site might
              require that all commits to a certain branch include a
              ticket number from the bug tracker, or that the incoming
              log message is non-empty).  The repository passes two
              arguments to this program: the path to the repository,
              and the name of the transaction being committed.  If the
              program returns a non-zero exit value, the commit is
              aborted and transaction is removed.</para>

            <para>The Subversion distribution includes a
              <command>commit-access-control.pl</command> script
              (located in the <filename>tools/hook-scripts</filename>
              directory of the Subversion source tree) that can be
              called from <command>pre-commit</command> to implement
              fine-grained access control.  At this time, this is the
              only method by which users can implement finer-grained
              access control beyond what
              <filename>httpd.conf</filename> offers.  In a future
              version of Subversion, we plan to implement ACLs
              directly in the filesystem.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>post-commit</filename></term>
          <listitem>
            <para>This is run after the transaction is committed, and
              a new revision is created.  Most people use this hook to
              send out descriptive emails about the commit or to make
              a perform a backup of the repository.  The repository
              passes two arguments to this program: the path to the
              repository, and the new revision number that was
              created.  The exit code of the program is ignored.</para>
                
            <para>The Subversion distribution includes a
              <command>commit-email.pl</command> script (located in
              the <filename>tools/hook-scripts/</filename> directory
              of the Subversion source tree) that can be used to send
              email with (and/or append to a log file) a description
              of a given commit.  This mail contains a list of the
              paths that were changed, the log message attached to the
              commit, the author and date of the commit, as well as a
              GNU diff-style display of the changes made to the
              various versioned files as part of the commit.</para>

            <para>Another useful tool provided by Subversion is the
              <command>hot-backup.py</command> script (located in the
              <filename>tools/backup/</filename> directory of the
              Subversion source tree).  This script performs hot
              backups of your Subversion repository (a feature
              supported by the Berkeley DB database backend), and can
              be used to make a per-commit snapshot of your repository
              for archival or emergency recovery purposes.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>pre-revprop-change</filename></term>
          <listitem>
            <para>Because Subversion's revision properties are not
              versioned, making modifications to such a property (for
              example, the <literal>svn:log</literal> commit message
              property) will overwrite the previous value of that
              property forever.  Since data can be potentially lost
              here, Subversion supplies this hook (and its
              counterpart, <filename>post-revprop-change</filename>)
              so that repository administrators can keep records of
              changes to these items using some externals means if
              they so desire.</para>

            <para>This hook runs just before such a modification is
              made to the repository.  The repository passes four
              arguments to this hook: the path to the repository, the
              revision on which the to-be-modied property exist, the
              authenticated username of the person making the change,
              and name of the property itself.</para>
          </listitem>
        </varlistentry>

        <varlistentry>
          <term><filename>pre-revprop-change</filename></term>
          <listitem>
            <para>As mentioned earlier, this hook is the counterpart
              of <filename>pre-revprop-change</filename> hook.  In
              fact, for the sake of paranoia this script will not run
              unless the <filename>pre-revprop-change</filename> hook
              exists.  When both of these hooks are present, the
              <filename>post-revprop-change</filename> hook runs just
              after a revision property has been changed, and is
              typically used to send an email containing the new value
              of the changed property.  The repository passes four
              arguments to this hook: the path to the repository, the
              revision on which the property exists, the authenticated
              username of the person making the change, and name of
              the property itself.</para>

            <para>The Subversion distribution includes a
              <command>propchange-email.pl</command> script (located
              in the <filename>tools/hook-scripts/</filename>
              directory of the Subversion source tree) that can be
              used to send email with (and/or append to a log file)
              the details of a revision property change.  This mail
              contains the revision and name of the changed property,
              the user who made the change, and the new property
              value.</para>
          </listitem>
        </varlistentry>
      </variablelist>

      <sidebar>
        <title>Sentinels, Those <quote>Other</quote> Hooks</title>

        <para>In addition to the hook scripts, Subversion has
          templates for two other special event handlers&mdash;the
          <filename>read-sentinels</filename> and
          <filename>write-sentinels</filename>.  These special
          programs, called <firstterm>sentinels</firstterm>, are
          intended to be daemon-like applications which are started at
          the beginning of a user's operation, and which receive
          multiple event notifications of a single type over the
          course of that operation.  Depending on the sentinel's
          responses to each of these notifications, Subversion may
          stop or otherwise modify the operation.  Fortunately for
          today's Subversion repository administrators, these
          sentinels can be ignored, since support for them is not yet
          implemented in Subversion itself!</para>
      </sidebar>
            
      <para>Subversion will attempt to execute hooks as the same user
        who owns the Subversion repository process.  In most cases,
        the repository is being access via Apache HTTP server and
        mod_dav_svn, so this user is the same user that Apache runs
        as.  The hooks themselves will need to be configured with
        OS-level permissions that allow that user to execute them.
        Also, this means that any file or programs (including the
        Subversion repository itself) accessed directly or indirectly
        by the hook will be accessed as the same user.  In other
        words, be alert to potential permissioning problems that might
        keep the hook from performing the tasks you've written it to
        perform.</para>

      <!--
      <para>The <command>pre-commit</command> and
        <command>post-commit</command> hooks need to know things about
        the change about to be committed (or that has just been
        committed).  The solution is a standalone program,
        <command>svnlook</command> <xref
        linkend="svn-ch-5-sect-1.2"/>.) which was installed in the
        same place as the <command>svn</command> binary.  Have the
        script use <command>svnlook</command> to examine a transaction
        or revision tree.  It produces output that is both human and
        machine-readable, so hook scripts can easily parse it.  Note
        that <command>svnlook</command> is read-only&mdash;it can only
        inspect, not change the repository.</para>
      -->
    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-1.2">
      <title>Berkeley DB configuration</title>

      <para>The Berkeley DB environment has it own set of default
        configuration values for things like the number of lock
        allowed to be taken out at any given time, or the size
        cutoff for Berkeley's journaling log file, etc.
        Subversion's filesystem code additional chooses default
        values for some of the Berkeley DB configuration options.
        However, sometimes your particular repository, with its
        unique collection of data and access patterns, might require
        a different set of configuration option values.</para>

     <para>The folks at Sleepycat (the producers of Berkeley DB)
        understand that different databases have different
        requirements, and so have provided a mechanism for runtime
        overwriting of many of the configuration values for the
        Berkeley DB environment.  Berkeley checks for the presence
        of a file named <filename>DB_CONFIG</filename> in each
        environment directory, and parses the options found in that
        file for use with that particular Berkeley
        environment.</para>

     <para>The Berkeley configuration overrides file for your
        repository is located in the <filename>db</filename>
        environment directory, at
        <filename>repos/db/DB_CONFIG</filename>.  Subversion
        itself creates this file and populates it with some default
        options, and with some pointers to the Berkeley DB online
        documentation so you can read about what those options do.</para>

    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 2:  REPOSITORY MAINTENANCE                          *** -->
  <!-- ******************************************************************* -->

  <sect1 id="svn-ch-5-sect-2">
    <title>Repository Maintenance</title>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-2.1">
      <title>Examining a Repository</title>
            
      <sect3 id="svn-ch-5-sect-2.1.1">
        <title>Understanding Transactions and Revisions</title>
        
        <para>A Subversion repository is essentially a sequence of
          directory trees, each tree a snapshot of how the file and
          directories versioned in your repository looked at various
          points in time.  These snapshots are created as a result of
          client operations, and are called
          <literal>revisions</literal>.</para>

        <para>Every revision begins life as a
          <literal>transaction</literal> tree.  When doing a commit, a
          client builds a Subversion transaction that mirrors their
          local changes, and then instructs the repository to store
          that tree as the next snapshot in the sequence.  If the
          commit succeeds, the transaction is effectively
          <quote>promoted</quote> into a new revision tree, and is
          assigned a new revision number.  If the commit fails for
          some reason, the transaction is destroyed and the client
          informed of the failure.</para>
            
        <para>At the moment, updates work in a similar way: the client
          builds a temporary transaction tree that mimics the state of
          their working copy.  The repository then compares that
          transaction tree with some revision tree (usually the most
          recent, or <quote>youngest</quote> tree, but the client may
          have requested otherwise), and sends back information that
          informs the client about what changes are needed to
          transform their working copy into a replica of the requested
          revision tree.  After the update completes, the temporary
          transaction is deleted.</para>
            
        <para>The use of transaction tree are the only way to make
          permanent changes to repository's versioned filesystem.
          However, it's important to understand that the lifetime of a
          transaction is completely flexible.  In the case of updates,
          transactions are temporary trees that are immediately
          destroyed.  In the case of commits, transactions are
          transformed into permanent revisions (or aborted if the
          commit fails).  In the case of an error or bug, it's
          possible that a transaction can be accidentally left lying
          around in the repository (not really affecting anything, but
          still taking up space).</para>

        <para>In theory, someday whole workflow applications might
          revolve around more fine-grained control of transaction
          lifetime.  It is feasible to imagine a system whereby each
          transaction slated to become a revision is left in statis
          well after the client finishes describing its changes to
          repository.  This would enable each new commit to be
          reviewed by someone else, perhaps a manager or engineering
          QA team, who can choose to promote the transaction into a
          revision, or abort it.</para>
            
        <para>You might at this point be wondering what all of this
          has to do with repository administration.  The answer is
          simple: if you're administering a Subversion repository,
          you're going to have to examine revisions and transactions.
          It's part of monitoring the health of, and tracking changes
          to, your repository.</para>
            
      </sect3>

      <sect3 id="svn-ch-5-sect-2.1.2">
        <title>svnlook</title>
            
        <para><command>svnlook</command> is a tool provided by
          Subversion for examining the various revisions and
          transaction in a repository.  No part of this program
          attempts to change the repository&mdash;it a
          <quote>read-only</quote> tool.  <command>svnlook</command>
          is the typically used by the repository hooks for reporting
          the changes that are about to be committed (in the case of
          the <command>pre-commit</command> hook) or that were just
          committed (in the case of the <command>post-commit</command>
          hook) to the repository.  Also, a repository administrator
          may find himself using this tool for diagnostic
          purposes.</para>
            
        <para>The simplest usage of <command>svnlook</command> is:</para>
            
        <screen>
$ svnlook path/to/repos
</screen>
            
        <para>This will print information about the youngest (or
          <quote>HEAD</quote>) revision in the repository
          <quote>repos</quote>.  Specifically, it will show the log
          message, author and date associated with that revision, as
          well as a diagram of the tree as it looks in that
          revision.</para>
            
        <para>To look at a particular revision or transaction, you can
          append the <literal>rev</literal> or <literal>txn</literal>
          arguments.  Note that while revision numbers appear as
          natural numbers, transaction names are alphanumeric strings.
          The following commands will generate the same kind of
          information as the previous one, except the information will
          be based on the revision or transaction supplied to
          <command>svnlook</command> instead of the default
          <literal>HEAD</literal> revision:</para>
            
        <screen>
$ svnlook path/to/repos rev 522
$ svnlook path/to/repos txn 3f7
</screen>
            
        <para>Output from <command>svnlook</command> is designed to be
          both human- and machine-parsable.  For example, the output
          of the usages we have covered thus far is defined to
          be:</para>

        <orderedlist>
          <listitem>
            <para>The author, followed by a newline.</para>
          </listitem>
          <listitem>
            <para>The date, followed by a newline.</para>
          </listitem>
          <listitem>
            <para>The number of characters in the log message,
              followed by a newline.</para>
          </listitem>
          <listitem>
            <para>The log message itself, followed by a newline.</para>
          </listitem>
          <listitem>
            <para>The directory tree, one directory or file per line,
              with each level of the heirachy indented by one column
              more than the previous level, and with directory names
              ending with a trailing slash (<literal>/</literal>)
              character.</para>
          </listitem>
        </orderedlist>

        <para>Here is an example of that output:</para>

        <screen>
$ svnlook path/to/repos rev 1
sally
2002-11-04 09:29:13 -0600 (Mon, 04 Nov 2002)
27
Added the usual Greek tree.
/
 A/
  B/
   lambda
   E/
    alpha
    beta
   F/
  mu
  C/
  D/
   gamma
   G/
    pi
    rho
    tau
   H/
    chi
    omega
    psi
 iota
</screen>

        <para>The <command>svnlook</command> can perform a variety of
          other queries, and accepts an optional subcommand argument
          to specify what information you actually wish the program to
          retrieve.  This subcommand argument is the last argument on
          the command-line, following even the revision and
          transaction specifier arguments.  The following is a brief
          description of the current list of subcommands accepted by
          <command>svnlook</command>, and the output of those
          subcommands:</para>

        <variablelist>
          <varlistentry>
            <term><literal>author</literal></term>
            <listitem>
              <para>Print the tree's author.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>date</literal></term>
            <listitem>
              <para>Print the tree's datestamp.</para>
            </listitem>
          </varlistentry>
          
          <varlistentry>
            <term><literal>changed</literal></term>
            <listitem>
              <para>List all files and directories that changed in the 
                tree.</para>
            </listitem>
          </varlistentry>
          
          <varlistentry>
            <term><literal>diff</literal></term>
            <listitem>
              <para>Print unified diffs of changed files.</para>
            </listitem>
          </varlistentry>
          
          <varlistentry>
            <term><literal>dirs-changed</literal></term>
            <listitem>
              <para>List the directories that changed in the tree.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>ids</literal></term>
            <listitem>
              <para>Print the tree listing, each directory and file
                annotated with its filesystem node revision ID.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>info</literal></term>
            <listitem>
              <para>Print the tree's author, datestamp, log message
                character count, and log message.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>log</literal></term>
            <listitem>
              <para>Print the tree's log message.</para>
            </listitem>
          </varlistentry>

          <varlistentry>
            <term><literal>tree</literal></term>
            <listitem>
              <para>Print the tree listing.</para>
            </listitem>
          </varlistentry>
        </variablelist>

        <para>You might have noticed that our description of the
          output from <command>svnlook</command> with no subcommand
          supplied does not fully match the descriptions of any one of
          the available subcommands.  That's because the default
          output is actually the concatenation of two of the
          subcommand's output, that of <literal>info</literal> and
          <literal>tree</literal>.  In fact, the following two
          commands should yeild exactly the same result:</para>

      <screen>
$ svnlook /path/to/repos
$ svnlook /path/to/repos info; svnlook /path/to/repos tree
</screen>

      </sect3>

      <sect3 id="svn-ch-5-sect-2.1.3">
        <title>The Shell</title>
            
        <para>The <command>svnadmin</command> tool has a toy
          <quote>shell</quote> mode as well.  It doesn't do much, but
          it allows you to poke around the repository as if it were an
          imaginary mounted filesystem.  The basic commands
          <literal>cd</literal>, <literal>ls</literal>,
          <literal>exit</literal>, and <literal>help</literal> are
          available, as well as the very special command
          <literal>cr</literal>&mdash;<quote>change revision</quote>.
          The last command allows you to move
          <emphasis>between</emphasis> revision trees.</para>
            
        <screen> 
$ svnadmin shell repos
&lt;609: /&gt;$
&lt;609: /&gt;$ ls
  &lt; 1.0.2i7&gt;  [   601]  1           0    trunk/
  &lt;nh.0.2i9&gt;  [   588]  0           0    branches/
  &lt;jz.0.18c&gt;  [   596]  0           0    tags/

&lt;609: /&gt;$ cd trunk
&lt;609: /trunk&gt;$ cr 500
&lt;500: /trunk&gt;$ ls
  &lt;   2.0.1&gt;  [     1]  0        3462    svn_config.dsp
  &lt;  4.0.dj&gt;  [   487]  0        3856    PORTING
  &lt;  3.0.cr&gt;  [   459]  0        7886    Makefile.in
  &lt;  d.0.ds&gt;  [   496]  0        9736    build.conf
  &lt;  5.0.d9&gt;  [   477]  1           0    ac-helpers/
  &lt;   y.0.1&gt;  [     1]  0        1805    subversion.dsp
&hellip;
&lt;500: /&gt;$ exit
</screen>
            
        <para>The output of <command>ls</command> has only a few
          columns:</para>
            
        <screen>
NODE-ID  CREATED-REV HAS_PROPS?  SIZE  NAME

&lt; 1.0.2i7&gt;  [   601]  1           0    trunk/
&lt;nh.0.2i9&gt;  [   588]  0           0    branches/
&lt;jz.0.18c&gt;  [   596]  0           0    tags/
</screen>
            
      </sect3>
    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-2.2">
      <title>Berkeley DB Management</title>
            
      <para>At the time of writing, the Subversion repository has only
        one database back-end:  Berkeley DB.  All of your filesystem's
        structure and data live in a set of tables within
        <filename>repos/db/</filename>.</para>
          
      <para>Berkeley DB comes with a number of tools for managing
        these files, and they have their own excellent documentation
        (see <systemitem
        class="url">http://www.sleepycat.com/</systemitem>, or read
        the BDB man pages).  We won't cover all of these tools here;
        rather, we'll mention just a few of the more common procedures
        that repository administrators might need.</para>
          
      <para>First, remember that Berkeley DB has genuine transactions.
        Every attempt to change the DB is first logged.  If anything
        ever goes wrong, the DB can back itself up to a previous
        <literal>checkpoint</literal> and replay transactions to get
        the data back into a sane state.</para>
            
      <para>In our experience, we have seen situations where a bug
        in Subversion (which causes a crash) can sometimes have a
        side-effect of leaving the DB environment in a
        <quote>locked</quote> state.  Any further attempts to read
        or write to the repository just sit there, waiting on the
        lock.</para>
          
      <para>To <quote>unwedge</quote> the repository:</para>
 
      <orderedlist>
        <listitem>
          <para>Shut down the Subversion server, to make sure nobody
            is accessing the repository's Berkeley DB files.</para>
        </listitem>
        <listitem> 
          <para>Switch to the user who owns and manages the database.</para>
        </listitem>
        <listitem>
          <para>Run the command <command>svnadmin recover
            /path/to/repos</command>.  You should see output like
            this:</para>
              
          <screen>
Acquiring exclusive lock on repository db, and running recovery procedures.
Please stand by...
Recovery completed.
The latest repos revision is 19.
</screen>
        </listitem>
        <listitem>
          <para>Restart the Subversion server.</para>
        </listitem>
      </orderedlist>
            
      <para>Make sure you run this command as the user that owns and
        manages the database&mdash;typically your Apache
        process&mdash;and <emphasis>not</emphasis> as root.  Running
        <command>db_recover</command> as root leaves files owned by
        root in the <filename>db</filename> directory, which the
        non-root user that manages the database cannot open.  If you
        do this, you'll get <quote>permission denied</quote> error
        messages when you try to access the repository.</para><!--
        ###TODO Make this a warning block? -Fitz -->
      
      <para>Second, a repository administrator may need to manage
        the growth of logfiles.  At any given time, the DB
        environment is using at least one logfile to log
        transactions; when the <quote>current</quote> logfile grows
        to 10 megabytes, a new logfile is started, and the old one
        continues to exist.</para>
          
      <para>Thus, after a while, you may see a whole group of 1MB
        logfiles lying around the environment.  At this point, you
        can make a choice: if you leave every single logfile behind,
        it's guaranteed that <command>db_recover</command> will
        always be able to replay every single DB transaction, all
        the way back to the first commit.  (This is the
        <quote>safe</quote>, or perhaps paranoid, route.)  On the
        other hand, you can ask Berkeley DB to tell you which
        logfiles are no longer being actively written to:</para>
          
      <screen>
$ db_archive -a -h repos/db
log.0000000023
log.0000000024
log.0000000029
</screen>
            
      <para>Subversion's own repository uses a
        <literal>post-commit</literal> hook script, which, after
        performing a <quote>hot-backup</quote> of the repository,
        removes these excess logfiles.  (In the Subversion source
        tree, see
        <filename>tools/backup/hot-backup.py</filename>).</para>
          
      <para>This script also illustrates the safe way to perform a
        backup of the repository while it's still up and running:
        recursively copy the entire repository directory, then
        re-copy the logfiles listed by <command>db_archive
        -l</command>.</para>
          
      <para>To start using a repository backup that you've restored,
        be sure to run <command>db_recover -v</command> command in
        the <filename>db</filename> area first.  This guarantees
        that any unfinished log transactions are fully played before
        the repository goes live again.  (The
        <command>hot-backup.py</command> script does that for you
        during backup, so you can skip this step if you decide to
        use it.)</para>
          
      <para>Finally, note that Berkeley DB has a whole locking
        subsystem; in extremely intensive svn operations, we have seen
        situations where the DB environment runs out of locks.  The
        maximum number of locks can be adjusted by changing the values
        in the <filename>repos/db/DB_CONFIG</filename> file.  Don't
        change the default values unless you know what you're doing;
        be sure to read <systemitem
        class="url">http://www.sleepycat.com/docs/ref/lock/max.html</systemitem>
        first.</para>
            
    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-2.3">
      <title>Tweaking with Svnadmin</title>
            
      <para>The <command>svnadmin</command> tool has some
        subcommands that are specifically useful to repository
        administrators.  Be careful with the
        <command>svnadmin</command>!  Unlike
        <command>svnlook</command>, which is read-only,
        <command>svnadmin</command> has the ability to modify the
        repository.</para>
          
      <para>The most-used feature is probably <literal>svnadmin
        setlog</literal>.  A commit's log message is an unversioned
        property directly attached to the revision object; there's
        only one log message per revision.  Sometimes a user screws
        up the message, and it needs to be replaced:</para>
          
      <screen>
$ echo "Here is the new, correct log message" > newlog.txt
$ svnadmin setlog myrepos 388 newlog.txt
</screen>
            
      <para>There's a nice CGI script in
        <filename>tools/cgi/</filename> that allows people (with
        commit-access passwords) to tweak existing log messages via
        web browser.</para>
          
      <para>Another common use of <command>svnadmin</command> is to
        inspect and clean up old, dead transactions.  Commits and
        updates both create transaction trees, but occasionally a
        bug or crash can leave them lying around.  By inspecting the
        datestamp on a transaction, an administrator can make a
        judgment call and remove it:</para>
          
      <screen>
$ svnadmin lstxns myrepos
319
321
$ svnadmin lstxns --long myrepos
Transaction 319
Created: 2002-07-14T12:57:22.748388Z
&hellip;
$ svnadmin rmtxns myrepos 319 321
</screen>
            
      <!-- ###TODO Hey guys, are going to continue to support
          svnadmin undeltify? -Ben -->
          
      <para>Another useful subcommand: <command>svnadmin
        undeltify</command>.  Remember that the latest version of
        each file is stored as fulltext in the repository, but that
        earlier revisions of files are stored as
        <quote>deltas</quote> against each next-most-recent
        revisions.  When a user attempts to access an earlier
        revision, the repository must apply a sequence of
        backwards-deltas to the newest fulltexts in order to derive
        the older data.</para>
          
      <para>If a particular revision tree is extremely popular, the
        administrator can speed up the access time to this tree by
        <quote>undeltifying</quote> any path within the
        revision&mdash; that is, by converting every file to
        fulltext:</para>
          
      <screen>
$ svnadmin undeltify myrepos 230 /project/tags/release-1.3
Undeltifying `/project/tags/release-1.3' in revision 230...done.
</screen>
            
    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-2.4">
      <title>Migrating a repository</title>
    
      <para>Sometimes special situations arise where you need to move
        all of your filesystem data from one repository to another.
        Perhaps the internal fs database schema has changed in some way
        in a new release of Subversion, or perhaps you'd like to start
        using a different database <quote>back end</quote>.</para>
  
      <para>Either way, your data needs to be migrated to a new
        repository.  To do this, we have the <command>svnadmin dump</command> and
        <command>svnadmin load</command> commands.</para>
  
      <para><command>svnadmin dump</command> writes a stream of your
        repository's data to stdout:</para>
  
      <screen>
$ svnadmin dump myrepos > dumpfile
* Dumped revision 0.
* Dumped revision 1.
* Dumped revision 2.
&hellip;
</screen>

      <para>This stream describes every revision in your repository as a
        list of changes to nodes.  It's mostly human-readable text; but
        when a file's contents change, the entire fulltext is dumped
        into the stream.  If you have binary files or binary
        property-values in your repository, those parts of the stream
        may be unfriendly to human readers.</para>
  
      <para>After dumping your data, you would then move the file to a
        different system (or somehow alter the environment to use a
        different version of <command>svnadmin</command> and/or
        <filename>libsvn_fs.so</filename>), and create a
        <quote>new</quote>-style repository that has a new schema or DB
        back-end:</para>
  
      <screen>
$ svnadmin create newrepos
</screen>
    
      <para>The <command>svnadmin load</command> command attempts to
        read a dumpstream from stdin, and effectively replays each
        commit:</para>
  
      <screen>
$ svnadmin load newrepos &lt; dumpfile
&lt;&lt;&lt; Started new txn, based on original revision 1
     * adding path : A ... done.
     * adding path : A/B ... done.
&hellip;
------- Committed new rev 1 (loaded from original rev 1) &gt;&gt;&gt;

&lt;&lt;&lt; Started new txn, based on original revision 2
     * editing path : A/mu ... done.
     * editing path : A/D/G/rho ... done.

------- Committed new rev 2 (loaded from original rev 2) &gt;&gt;&gt;
</screen>

      <para>Voila, your revisions have been recommitted into the new
        repository.</para>
      
      <para>And because <command>svnadmin</command> uses standard input
        and output streams for the repository dump and load process,
        people who are feeling saucy with Unix can try things like
        this:</para>
  
      <screen>
$ svnadmin create newrepos
$ svnadmin dump myrepos | svnadmin load newrepos
</screen>

      <para>You can also create a dumpfile that represents a specific
        range of revisions.  <command>svnadmin dump</command> takes
        optional starting and ending revisions to accomplish just that
        task.</para>

      <screen>
$ svnadmin dump myrepos 23 > rev-23.dumpfile
$ svnadmin dump myrepos 100 200 > revs-100-200.dumpfile
</screen>

      <para>Now, regardless of the range of revisions used when
        dumping the repository, the default behavior is for the first
        revision dumped to always be compared against revision 0,
        which is just the empty root directory <filename>/</filename>.
        This means that the first revision in any dumpfile will always
        look like a gigantic list of <quote>added</quote> nodes.  We
        do this so that a file like
        <filename>revs-100-200.dumpfile</filename> can be directly
        loaded into an empty repository.</para>

      <para>However, if you add the <option>--incremental</option>
        option when you dump your repository, this tells
        <command>svnadmin</command> to compare the first dumped
        revision against the previous revision in the repository, the
        same way it treats every other revision that gets dumped.  The
        benefit of this is that you can create several small dumpfiles
        that can be loaded in succession, instead of one large one,
        like so:</para>

      <screen>
$ svnadmin dump myrepos 0 1000 > dumpfile1
$ svnadmin dump myrepos 1001 2000 --incremental > dumpfile2
$ svnadmin dump myrepos 2001 3000 --incremental > dumpfile3
</screen>

      <para>These dumpfiles could be loaded into a new repository with
        the following command sequence:</para>

      <screen>
$ svnadmin load newrepos &lt; dumpfile1
$ svnadmin load newrepos &lt; dumpfile2
$ svnadmin load newrepos &lt; dumpfile3
</screen>

      <para>Another neat trick you can perform with this
        <option>--incremental</option> option involves appending to an
        existing dumpfile a new range of revisions.  For example, you
        might have a post-commit hook that simply appends the
        repository dump of the single revision that triggered the
        hook.  Or you might have a script like the following that runs
        nightly to append dumpfile data for all the revisions that
        were added to the repository since the last time the script
        ran.</para>

      <screen>
#!/usr/bin/perl

$repos_path  = '/path/to/repos';
$dumpfile    = '/usr/backup/svn-dumpfile';
$last_dumped = '/var/log/svn-last-dumped';
 
# Figure out the starting revision (0 if we cannot read the last-dumped file,
# else use the revision in that file incremented by 1).
if (open LASTDUMPED, "$last_dumped")
{
    $new_start = &lt;LASTDUMPED&gt;;
    chomp $new_start;
    $new_start++;
    close LASTDUMPED;
}
else
{
    $new_start = 0;
}

# Query the youngest revision in the repos.
$youngest = `svnadmin youngest $repos_path`;
chomp $youngest;

# Do the backup.
`svnadmin dump $repos_path $new_start $youngest --incremental >> $dumpfile`;

# Store a new last-dumped revision
open LASTDUMPED, "> $last_dumped" or die;
print LASTDUMPED "$youngest\n";
close LASTDUMPED;

# All done!
</screen>

      <para>As you can see, the Subversion repository dumpfile format,
        and specifically <command>svnadmin</command>'s use of that
        format, can be a valuable means by which to backup changes to
        your repository over time in case of a system crash or some
        other catastrophic event.</para>

    </sect2>
  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 3:  NETWORKING A REPOSITORY                         *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-5-sect-3">
    <title>Networking a Repository</title>
          
    <para>Okay, so now you have a repository, and you want to make it
      available over a network.</para>
            
    <para>Subversion's primary network server is Apache httpd speaking
      WebDAV/deltaV protocol, which is a set of extension methods to
      http.  (For more information on DAV, see <systemitem
      class="url">http://www.webdav.org/</systemitem>.)</para>
            
    <para>To network your repository, you'll need to</para>

    <itemizedlist>
      <listitem>
        <para>Get Apache httpd 2.0 up and running with the mod_dav
          module.</para>
      </listitem>
      <listitem>
        <para>Install the mod_dav_svn plugin to mod_dav, which uses
          Subversion's libraries to access the repository.</para>
      </listitem>
      <listitem>
        <para>Configure your <filename>httpd.conf</filename>
          file to export the repository.</para>
      </listitem>
    </itemizedlist>

    <para>You can accomplish the first two items by either building
      httpd and Subversion from source code, or by installing a
      binary packages on your system.  The second appendix of this
      document contains more detailed instructions on doing
      this. (<xref linkend="svn-ch-5"/><!-- ###TODO link this to
      'Compiling-and-installing' -Fitz -->.)  Instructions are also
      available in the <filename>INSTALL</filename> file in
      Subversion's source tree.</para><!-- ###TODO Do we really want
      to point to the INSTALL doc? -->
          
    <para>In this section, we focus on configuring your
      <filename>httpd.conf</filename>.</para>
          
    <para>Somewhere near the bottom of your configuration file,
      define a new <literal>&lt;Location&gt;</literal> block:</para>
            
    <screen>
&lt;Location /repos/myrepo&gt;
  DAV svn
  SVNPath /absolute/path/to/myrepo
&lt;/Location&gt;
</screen>
            
    <para>This now makes your <filename>myrepo</filename> repository
      available at the URL <systemitem
      class="url">http://hostname/repos/myrepo</systemitem>.</para>
        
    <para>Alternately, you can use the
      <literal>SVNParentPath</literal> directive to indicate a
      <quote>parent</quote> directory whose immediate subdirectories
      are assumed to be independent repositories:</para>
          
    <screen>
&lt;Location /repos&gt;
  DAV svn
  SVNParentPath /absolute/path/to/parent/dir
&lt;/Location&gt;
</screen>
            
    <para>If you were to run <command>svnadmin create
      foorepo</command> within this parent directory, then the url
      <systemitem
      class="url">http://hostname/repos/foorepo</systemitem> would
      automatically be accessible without having to change
      <filename>httpd.conf</filename> or restart httpd.</para>
        
    <para>Note that this simple <literal>&lt;Location&gt;</literal>
      setup starts life with no access restrictions at all:</para>
          
    <itemizedlist>
      <listitem>
        <para>Anyone can use their svn client to checkout either a
          working copy of a repository URL, or of any URL that
          corresponds to a subdirectory of a repository.</para>
      </listitem>
      <listitem>
        <para>By pointing an ordinary web browser at a repository
          URL, anyone can interactively browse the repository's
          latest revision.</para>
      </listitem>
      <listitem>
        <para>Anyone can commit to a repository.</para>
      </listitem>
    </itemizedlist>
    
    <para>If you want to restrict either read or write access to a
      repository as a whole, you can use Apache's built-in access
      control features.</para>
          
    <para>First, create an empty file that will hold httpd usernames
      and passwords.  Place names and crypted passwords into this
      file like so:</para>
          
    <screen>
joe:Msr3lKOsYMkpc
frank:Ety6rZX6P.Cqo
mary:kV4/mQbu0iq82
</screen>
 
    <para>You can generate the crypted passwords by using the
      standard <literal>crypt(3)</literal> command, or using the
      <command>htpasswd</command> tool supplied in Apache's
      <filename>bin</filename> directory:</para>
          
    <screen>
$ /usr/local/apache2/bin/htpasswd -n sussman
New password: 
Re-type new password: 
sussman:kUqncD/TBbdC6
</screen>
          
    <para>Next, add lines within your
      <literal>&lt;Location&gt;</literal> block that point to the
      user file:</para>
          
    <screen>
AuthType Basic
AuthName "Subversion repository"
AuthUserFile /path/to/users/file
</screen>
            
    <para>If you want to restrict <emphasis>all</emphasis> access to
      the repository, add one more line:</para>
          
    <screen>
Require valid-user
</screen>
            
    <para>This line makes Apache require user authentication for
      every single type of http request to your repository.</para>
          
    <para>To restrict write-access only, you need to require a valid
      user for all request methods <emphasis>except</emphasis> those
      that are read-only:</para>
          
    <screen>
&lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
  Require valid-user
&lt;/LimitExcept&gt;
</screen>
            
    <para>Or, if you want to get fancy, you can create two separate
      user files, one for readers, and one for writers:</para>
        
    <screen>
AuthGroupFile /my/svn/group/file

&lt;LimitExcept GET PROPFIND OPTIONS REPORT&gt;
  Require group svn_committers
&lt;/LimitExcept&gt;

&lt;Limit GET PROPFIND OPTIONS REPORT&gt;
   Require group svn_committers
   Require group svn_readers
&lt;/Limit&gt;
</screen>
            
    <para>These are only a few simple examples.  For a complete
      tutorial on Apache access control, please consider taking a look
      at the <quote>Security</quote> tutorials found at <systemitem
      class="url">http://httpd.apache.org/docs-2.0/misc/tutorials.html</systemitem>.</para>
          
    <para>Another note: in order for <command>svn cp</command> to
      work (which is actually implemented as a <literal>DAV
      COPY</literal> request), mod_dav needs to be able to be able
      to determine the hostname of the server.  A standard way of
      doing this is to use Apache's <literal>ServerName</literal>
      directive to set the server's hostname.  Edit your
      <filename>httpd.conf</filename> to include:</para>
          
    <screen>
ServerName svn.myserver.org
</screen>
            
    <para>If you are using virtual hosting through Apache's
      <literal>NameVirtualHost</literal> directive, you may need to
      use the <literal>ServerAlias</literal> directive to specify
      additional names that your server is known by.</para>
          
    <para>(If you are unfamiliar with an Apache directive, or not
      exactly sure about what it does, don't hesitate to look it up
      in the documentation: <systemitem
      class="url">http://httpd.apache.org/docs-2.0/mod/directives.html</systemitem>.)</para>
          
    <para>You can test your exported repository by firing up httpd:</para>
          
    <screen>
$ /usr/local/apache2/bin/apachectl stop
$ /usr/local/apache2/bin/apachectl start
</screen>
            
    <para>Check
      <filename>/usr/local/apache2/logs/error_log</filename> to make
      sure it started up okay.  Try doing a network checkout from
      the repository:</para>
          
    <screen>
$ svn co http://localhost/repos wc
</screen>
            
    <para>The most common reason this might fail is permission
      problems reading the repository db files.  Make sure that the
      user <literal>nobody</literal> (or whatever
      <literal>UID</literal> the httpd process runs as) has
      permission to read and write the Berkeley DB files!  This is a
      very common problem.</para>
          
    <para>You can see all of mod_dav_svn's complaints in the Apache
      error logfile,
      <filename>/usr/local/apache2/logs/error_log</filename>, or
      wherever you installed Apache.  For more information about
      tracing problems, see "Debugging the server" in the
      <filename>HACKING</filename> file.</para><!-- ###TODO Do we
      want to point to the HACKING file? -Fitz -->

  </sect1>

  <!-- ******************************************************************* -->
  <!-- *** SECTION 4:  ADDING PROJECTS                                 *** -->
  <!-- ******************************************************************* -->
  <sect1 id="svn-ch-5-sect-4">
    <title>Adding projects</title>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-4.1">
      <title>Examples of 'svn import'</title>
          
      <para>Once the repository has been created, it's very likely
        that you'll want to use the svn client to import an initial
        tree.  See <xref linkend="svn-ch-5"/><!-- ###TODO link this to
        'other commands' -Fitz -->.)</para>
          
      <para>You may want to give your repository an initial directory
        structure that reflects the trunk, branches, and tags of your
        project(s) (See <xref linkend="svn-ch-4"/>.)  You can do this
        via <command>svn mkdir</command>:</para>
            
      <screen>
$ svnadmin create /path/to/repos
$ svn mkdir file:///path/to/repos/projectA -m 'Base dir for A'
Committed revision 1.
            
$ svn mkdir file:///path/to/repos/projectA/trunk -m 'Main dir for A'
Committed revision 2.
            
$ svn mkdir file:///path/to/repos/projectA/branches -m 'Branches for A'
Committed revision 3.
            
$ svn mkdir file:///path/to/repos/projectA/tags -m 'Tags for A'
Committed revision 4.
            
$ svn co file:///path/to/repos/projectA/trunk projectA
Checked out revision 4.
             
# ... now work on projectA ...
</screen>
          
      <para>With <command>svn import</command>, you can create the
        structure with a single commit:</para>
            
      <screen>
$ svnadmin create /path/to/repos
$ mkdir projectA
$ mkdir projectA/trunk
$ mkdir projectA/branches
$ mkdir projectA/tags    
$ svn import file:///path/to/repos projectA projectA -m 'Dir layout for A'
Adding         projectA/trunk
Adding         projectA/branches
Adding         projectA/tags
Committed revision 1.

$ rm -rf projectA/
$ svn co file:///path/to/repos/projectA/trunk projectA
Checked out revision 1.
            
#  ... now work on projectA ...
</screen>

    </sect2>

    <!-- ***************************************************************** -->
    <sect2 id="svn-ch-5-sect-4.2">
      <title>Vendor Branches</title>
      
      <para>(discussion of strategies and svn_load_dirs.pl)</para>

      <para>###TODO write this.</para>

    </sect2>

  </sect1>
</chapter>

<!--
local variables: 
eval: (load-file "../tools/svnbook.el")
sgml-parent-document: ("book.xml" "chapter")
end:
-->
